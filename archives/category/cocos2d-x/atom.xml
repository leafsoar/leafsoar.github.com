<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2d-x | /无间落叶]]></title>
  <link href="http://blog.leafsoar.com/archives/category/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://blog.leafsoar.com/"/>
  <updated>2014-03-30T21:23:16+08:00</updated>
  <id>http://blog.leafsoar.com/</id>
  <author>
    <name><![CDATA[一叶]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何优雅的管理游戏资源]]></title>
    <link href="http://blog.leafsoar.com/archives/2013/11-27.html"/>
    <updated>2013-11-27T20:56:00+08:00</updated>
    <id>http://blog.leafsoar.com/archives/2013/res-mgr</id>
    <content type="html"><![CDATA[<p>在游戏的开发过程中，<strong>前期的规划 往往比 后期的“优化”更为重要！</strong>比如多分辨率适配，如果前期没有规划好，可能导致的情况是，画面只在当前测试开发机或者一部分机型正常显示。做了多套资源适配，可以使在合适的机型使用对应的图片资源，避免在高清屏幕使用低质量的图片，在低分辨率屏幕因为图片太大而浪费硬件资源。机制与策略分离，可以让你设计出简单有效的接口。模块化的设计可以让你组织好各种逻辑流程，条理分明 ~ 前期的规划工作可以有很多，一叶也在摸索之中，以使游戏的开发尽量变的简单灵活且可控。最简单的也是最容易忽略的地方，跟我们打交道最多的要数精灵了，从图片创建一个精灵，很简单的开端，将以此展开行动 ~</p>

<p>本文使用 Cocos2d-3.0alpha1 版本，创建了一个 C++ 项目，介绍在 C++ 中，如何处理资源相关的内容，如果读者使用脚本，也可以参考本文中资源管理理念而忽略语言特性，你可以在 Github<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 上面看到本文所有源码。</p>

<!-- more -->


<h2>名字系统</h2>

<p>也许你可称之为“命名规范”，但显然它无法表达我所想说的内容，很多人在创建精灵的时候喜欢直接使用资源名称，而没有任何定义，这是一个不好的习惯，如果游戏资源不存在，缺少，或者修改名字，如此你需要在多出引用的地方一一修改。游戏开发中的变数总是无法预料，合理的“名字系统”可以节省很多人力。</p>

<p>我们设定一个文件，这里名为 “Resources.h” 的文件，在其中定义所有的资源名称，在游戏开发中，<strong>尽量只</strong> 使用此处的名称，如图片名称，字体名称，声音资源等。这样做有以下好处，只是简单说几点：</p>

<ul>
<li>如果对资源做出修改，我们可以修改此处定义，以保证同步，避免缺失，命名错误，错误引用等问题</li>
<li>在图片名定义修改时，编译器会编译出错，并自动帮助我们 “找” 出引用的地方，方便修改</li>
<li>由于有常量定义的缘故，我们的 IDE 会自动补全所有以定义变量名称，减少出错的可能，提高效率</li>
<li>这个文件列表显然可以写一个如 python 脚本自动生成</li>
</ul>


<p>使用脚本来自动生成文件常量定义显然是个行之有效的途径，这种机械式的操作交给脚本就行了，它总能出色的完成任务，首先来看看项目的 Resources 目录内容：</p>

<p>``` bash</p>

<pre><code>[Resources]~ ./tree    
├── CloseNormal.png
├── CloseSelected.png
├── HelloWorld.png
├── file_list.json
├── fonts
│   └── Marker\ Felt.ttf
└── images
    ├── JungleLeft.png
    ├── ghosts.plist
    ├── ghosts.png
    ├── grossini_family.plist
    └── grossini_family.png
</code></pre>

<p>```</p>

<p>以上是资源文件，那么通过脚本所生成的 “Resources.h” 文件又是什么样子的呢，脚本在 Github 仓库中可以找到(<strong>注意：资源名中最好不要有空格，以免留下“隐患”</strong>)：</p>

<p>``` c++</p>

<pre><code>#ifndef _AUTO_RESOURCES_H_
#define _AUTO_RESOURCES_H_

// search paths
static const std::vector&lt;std::string&gt; searchPaths = {
  "fonts",
  "images",
};

// files
static const char si_CloseNormal[]         = "CloseNormal.png";
static const char si_CloseSelected[]       = "CloseSelected.png";
static const char sjs_file_list[]      = "file_list.json";
static const char si_HelloWorld[]      = "HelloWorld.png";
static const char st_MarkerFelt[]      = "Marker Felt.ttf";
static const char sp_ghosts[]      = "ghosts.plist";
static const char si_ghosts[]      = "ghosts.png";
static const char sp_grossini_family[]         = "grossini_family.plist";
static const char si_grossini_family[]         = "grossini_family.png";
static const char si_JungleLeft[]      = "JungleLeft.png";
</code></pre>

<h1>endif // <em>AUTO_RESOURCES_H</em></h1>

<p>```</p>

<p>看到通过脚本，我们生成了所有文件的常量定义，这让得我们可以在游戏中任意使用，但是请注意，这里生成的文件名称是没有包含路径的，所以在定义文件之前，也自动生成了目录列表 <strong>searchPaths</strong>，顾名思义，设定了一个目录列表，以便找寻资源，我们可以在程序的开始处使用 <code>FileUtils::getInstance()-&gt;setSearchPaths(searchPaths);</code> 来设定游戏的资源目录列表，这样我们就可以不用关心资源所在的目录了，你甚至可以根据需要合理的调整资源目录。</p>

<p><strong>注意</strong>：通过设置 searchPaths 可以让我们不用关系资源的路径所在，那么意味着资源名称必须唯一，否则可能会出现引用问题。其次，是如果使用了多套资源方案，请注意 searchPaths 的先后顺序关系。本文暂不考虑多套资源。关于忽略资源目录的做法，如果有不同看法者，欢迎留言讨论，对我来说，忽略路径是利大于弊的 ~</p>

<p>以上通过脚本自动生成了文件列表，但是这显然不够，我们看到资源当中有两张 <strong>打包</strong> 资源图片（可以使用 TexturePacker 对图片资源进行打包，具有占用更小空间，优化运行效率等诸多好处，后面还会介绍此点） plist 文件。我们当然也是需要使用打包中资源的，所以脚本需要能够自动解析 plist 文件，并提取出 TexturePacker 打包的资源名称，请看如下定义，同样是自动生成在 “Resources.h” 文件之中：</p>

<p>``` c++</p>

<pre><code>////// texture //////

// ghosts.plist
static const char si_child1[]      = "child1.gif";
static const char si_father[]      = "father.gif";
static const char si_sister1[]         = "sister1.gif";
static const char si_sister2[]         = "sister2.gif";

// grossini_family.plist
static const char si_grossini[]        = "grossini.png";
static const char si_grossinis_sister1[]       = "grossinis_sister1.png";
static const char si_grossinis_sister2[]       = "grossinis_sister2.png";
</code></pre>

<p>```</p>

<p>此时我们就能用以下代码来创建精灵了，都引用了资源名称定义，并且使用两种方式创建了精灵：</p>

<p>``` c++</p>

<pre><code>// 直接由图片创建精灵
auto hello = Sprite::create(si_HelloWorld);

// 从打包资源创建精灵
SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile(sp_grossini_family, si_grossini_family);
auto sister = Sprite::createWithSpriteFrameName(si_grossinis_sister1);
</code></pre>

<p>```
上面我们使用两种方式创建精灵，为什么会有两种方式？也许你可以看看 <a href="http://blog.zilongshanren.com/">『子龙山人』</a> 翻译的文章 <a href="http://www.cnblogs.com/zilongshanren/archive/2011/03/18/1988097.html">『在cocos2d里面如何使用Texture Packer和像素格式来优化spritesheet』</a>
其中详细的介绍了图片资源打包优化的相关细节问题，一个游戏最多的就是图片资源，优化空间最大的也是图片资源，里面详细的介绍了优化图片资源占用空间 50％ 以上，如何使游戏运行内存占用优化近 50％，以 cocos2d 为例，但 cocos2d-x 同样能够适用，而且能通过脚本自动打包。 所以合理的对图片资源进行打包优化是非常有必要的。但如何处理这个流程确实不好定夺，<strong>因为不同资源的使用方式不同，因为这两种方式的存在，导致我们编写代码的逻辑不同，这需要提前预定好，</strong>所以我们考虑如下开发流程：</p>

<p>在游戏开发前，对所有资源打包后提供给 编写游戏人员，也就是说在写程序之前，游戏资源就已确定，那些以打包，哪些未打包都已经知道，如前面一样，通过两种方式创建精灵。但是这样的结果是，前期规定好了的，后期就无法改动，或者说很难改动，牵一发而动全身啊 ~ 这就需要加大 <strong>前期的规划</strong> 力度，以确保后期不会出现太大太多事与愿违的情形。这种情况下的 <strong>后期优化</strong> 将会非常蹩脚。况且加大前期规划的力度，可能会对整个项目的进程有所影响，如比编写人员的动工会稍缓，人力资源分配不合理。</p>

<h3>透明</h3>

<p>前文提到，我们使用了 searchPaths 变量，以用忽略资源的路径，一个存在的东西，看起来好像不存在一样，我们称之为 “透明”，”透明” 在软件领域中也是重要的概念，它也强调着封装的重要性，隐藏细节的必要性。这里的资源路径就是如此，我们可以说 <strong>对于资源的使用来说，它的路径是透明的，</strong> 有没有路径，路径为何？那不重要，重要的是你能通过资源名称获取想要的资源。</p>

<p>也许你已经发现了，我想说的不是路径问题，而是图片资源问题。<strong>对于图片资源的使用来说，它’是否是打包资源’ 应该是透明的。</strong>也既是在使用图片资源的时候，你不应该关心它是不是打包后的资源，是也好，不是也罢，这不应该影响你对资源的请求和使用。”打包” 这个过程对你来说，<strong>不存 ~</strong></p>

<h2>图片资源类型的 “透明化” 处理</h2>

<p>先来段代码，看看没有 “透明化” 处理时的一般使用方式：</p>

<p>``` c++</p>

<pre><code>// 方式一  文件资源
auto jungle = Sprite::create(si_JungleLeft);

// 方式二  打包资源
SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile(sp_grossini_family, si_grossini_family);
auto sister = Sprite::createWithSpriteFrameName(si_grossinis_sister1);
</code></pre>

<p>```</p>

<p>以上我们看到，同样是创建精灵， <code>si_JungleLeft</code> 是普通的 <strong>文件资源</strong>，而 <code>si_grossinis_sister1</code> 是 <strong>打包资源</strong>，这决定着两者的使用方式不同，那么怎么 “透明化” 处理呢：</p>

<p>``` c++</p>

<pre><code>// 不论图片属于 文件资源 还是 打包资源 使用方法相同
auto jungle = AssetLoader::createSprite(si_JungleLeft);
auto jungle = AssetLoader::createSprite(si_grossinis_sister1);
</code></pre>

<p>```</p>

<p>我们提供了一个类 <code>AssetLoader</code>，它有一个方法 <code>createSprite(const std::string&amp; name)</code>。不论我们是不是打包资源，我们都通过这个方法来创建精灵，显然它的内部工作原理是根据图片的实际类型，动态判断并创建，之后返回，要实现这样一个功能是可行的，并且没有多复杂，实现以后。我们在使用图片资源的使用就再也用关心它是什么类型的资源了。</p>

<p><strong>这也意味着你可以以一个理想的方式来管理开发流程</strong>。 图片资源可以和游戏编写同时进行，不停的添加图片资源，不停的编写游戏逻辑，而不用考虑图片是否已经优化的问题了，此时可以提供一些零散的图片，以供使用（图片命名最好还是固定），当然也可以提前把关联性比较强的图片提前打包处理，这并不影响使用，因为对程序来说，<strong>它是透明的</strong>，”不存在”的。在后期，我们可以集中的在后期对游戏资源优化，打包处理等（关于此点，文章后面也会给出相对合理的处理流程）。</p>

<h3>功能的实现方案与流程</h3>

<p>在开始之前，一叶通常会将其流程在心中演算一遍，使其不会出现太大的纰漏，对于不合理的所在，可以重新拟定方案。然后实现之 ~ 要使得 <strong>AssetLoader</strong> 的 <strong>createSprite</strong> 方法完成其功能，那么它需要知道，当前请求的 <strong>图片资源</strong> 是否是 <strong>文件资源</strong>（以 <strong>文件资源</strong> 和 <strong>打包资源</strong> 区分两者），如果是，直接由前文 <strong>方式一</strong> 创建精灵返回，如果不是，则从 打包资源 里面找寻，找到就通过 <strong>方式二</strong> 创建精灵并返回，如果还没找到，就返回空指针喽 ~ 由此我们知道 AssetLoader 它内部需要完成以下功能：</p>

<ul>
<li>能够判断一个资源是否是文件资源</li>
<li>能够根据打包资源图片名称返回实际的 plist 文件（打包资源描述文件）和 图片文件</li>
</ul>


<p>要完成以上功能，那就需要让 AssetLoader 知道有哪些文件资源，还要知道有哪些打包资源，我们可以在 AssetLoader 里面定义几个字典用以保存这些数据：</p>

<p>``` c++</p>

<pre><code>class AssetLoader: public Object{
public:
    static Sprite* createSprite(const std::string&amp; name);

private:
    static AssetLoader* getInstance();
    bool init();

    bool fileExists(const std::string&amp; filename);
    std::string getTexturePlist(const std::string&amp; name);
    std::string getTextureImage(const std::string&amp; name);

private:
    Dictionary* _fileDict;              // 文件列表
    Dictionary* _texturePlistDict;           // 打包资源到文件的映射
    Dictionary* _textureImageDict;       // 打包资源plist 到图片的映射
};
</code></pre>

<p>```</p>

<p>如以上的定义实现，它有三个字典， <code>_fileDict</code> 的 <strong>key</strong> 保存着所有文件资源，<strong>value</strong> 保存文件资源的 编号 ，这样我们就能够随时判断一个图片是否是文件资源了。<code>_texturePlistDict</code> 的 key 保存着打包资源的名称，value 保存打包资源所在 Plist 文件的编号，通过它我们能通过打包资源获取到它 Plist 所在的文件。 <code>_textureImageDict</code> 也是类似，key 保存打包资源名称，value 保存打包资源所在的真实 图片文件的引用。</p>

<p>功能已经定义完毕，现在的问题是我们如何去为这几个字典填充数据？显然程序初始化手动填充不靠谱，前文的文件名等信息都已经是自动定义了，此处我们当然也希望有一个方案 <strong>自动填充</strong> 了。这里的做法是，在使用 <strong>python</strong> 生成资源定义的时候，同时生成一个 json 文件，这个文件里面包含了所有此处字典中所需要的数据，然后 <strong>AssetLoader</strong> 初始化的时候读取这个 json 文件，以完成自动填充数据的功能。先来看看自动生成的 json 文件长什么样纸：</p>

<p>题外话：使用 json 来存储这样一个中转的数据格式是最后定下来的方案，设计之初考虑过几种方案，比如想到可以用一个 sqlite 数据来保存各种数据，这样数据的操作就非常统一，对后期的数据统计分析也会非常方便，曾与朋友 子龙山人 讨论过这之间的详细细节，以及各种实现方案的利弊分析。使用 sqlite 的好处是更为灵活，后期扩展功能会非常方便，适合稍微大点的项目，但是如果一个项目本身没有使用 sqlite 数据库，如果为这里的方案而硬添加一个扩展库实现 sqlite，可能就会非常的不友好，不通用。</p>

<p>```
{
  &ldquo;file_name&rdquo;: [</p>

<pre><code>"CloseNormal.png",
"CloseSelected.png",
"file_list.json",
"HelloWorld.png",
"Marker Felt.ttf",
"ghosts.plist",
"ghosts.png",
"grossini_family.plist",
"grossini_family.png",
"JungleLeft.png"
</code></pre>

<p>  ],
  &ldquo;file_index&rdquo;: [</p>

<pre><code>  "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"
</code></pre>

<p>  ],
  &ldquo;texture_name&rdquo;: [</p>

<pre><code>"child1.gif",
"father.gif",
"sister1.gif",
"sister2.gif",
"grossini.png",
"grossinis_sister1.png",
"grossinis_sister2.png"
</code></pre>

<p>  ],
  &ldquo;texture_plist&rdquo;: [</p>

<pre><code>"6", "6", "6", "6", "8", "8", "8"
</code></pre>

<p>  ],
  &ldquo;texture_image&rdquo;: [</p>

<pre><code>"7", "7", "7", "7", "9", "9", "9"
</code></pre>

<p>  ]
 }
```</p>

<p>以上是自动生成的 json 数据文件内容，为了在这里展示，做了点格式化和缩进，更为友好一点。通过 <strong>file_name</strong> 和 <strong>file_index</strong> 可以创建文件资源列表字典，通过 texture_name 和 texture_plist 可以创建打包资源和文件资源之间的映射， texture_image 也是同样。 file_name 包含了所有文件资源，file_index 为文件资源做了编号，这两个数据项的个数是相同的。 texture_name 定义了所有打包资源的定义，texture_plist 和 texture_image 则保存了 打包资源所在的 plist 文件和图片文件的引用，它们的数据项个数也是相同的。只要保证这里生成的内容没有错误，那么我们就正确的将其填充到 AssetLoader 的字典里面，以实现想要的功能。</p>

<p>为什么数据会长这个样子？一叶本来的设计 json 文件，多层嵌套更具描述性（各种对象，各种属性，一目了然），但是发现 解析的时候稍显麻烦，在 新版 cocos2d-x 的 gui 库中，已经封装好了一些常用的 json 解析功能，本着 拿来注意（尽可能的寻找可用的资源来简化自身的流程） 的思想，为使解析过程简单，所以数据格式就定义成那个样子了 － ＝。现在只是用了五个数组（更平面化的数据组织，像是数据库表），保存所有数据。只能说，这样做是为了迎合代码的编写，让本来复杂的 json 解析过程变得更为简单。现在看来，但到也简单清晰，看看填充字典的关键代码实现（如果有其它更好的方式，修改也不麻烦，修改生成的数据格式，再修改代码中数据的填充方法就行了）：</p>

<p>``` c++</p>

<pre><code>JsonDictionary *jsonDict = new JsonDictionary();
String* fileContent = String::createWithContentsOfFile(sjs_file_list);
jsonDict-&gt;initWithDescription(fileContent-&gt;getCString());

DictionaryHelper* dicHelper = DICTOOL;

_fileDict = Dictionary::create();
int file_idx = dicHelper-&gt;getArrayCount_json(jsonDict, file_name);
for (int i = 0; i &lt; file_idx; i++){
    std::string name = dicHelper-&gt;getStringValueFromArray_json(jsonDict, file_name, i);
    std::string index = dicHelper-&gt;getStringValueFromArray_json(jsonDict, file_index, i);
    _fileDict-&gt;setObject(String::create(index), name);
}
log("file count: %d", file_idx);

_texturePlistDict = Dictionary::create();
int texture_idx = dicHelper-&gt;getArrayCount_json(jsonDict, texture_name);
for (int i = 0; i &lt; texture_idx; i++){
    std::string name = dicHelper-&gt;getStringValueFromArray_json(jsonDict, texture_name, i);
    std::string plist = dicHelper-&gt;getStringValueFromArray_json(jsonDict, texture_plist, i);
    _texturePlistDict-&gt;setObject(String::create(plist), name);
}
log("texture count: %d", texture_idx);

_textureImageDict = Dictionary::create();
for (int i = 0; i &lt; texture_idx; i++){
    std::string name = dicHelper-&gt;getStringValueFromArray_json(jsonDict, texture_name, i);
    std::string image = dicHelper-&gt;getStringValueFromArray_json(jsonDict, texture_image, i);
    _textureImageDict-&gt;setObject(String::create(image), name);
}

CC_SAFE_DELETE(jsonDict);
</code></pre>

<p>```</p>

<p>这里能看到一些陌生的内容 <code>JsonDictionary</code>、<code>DictionaryHelper</code> 类型和其操作方式，这里的使用方法不是本文的重点，有兴趣的朋友看看源码实现。以很简洁的方式，填充了我们需要的字典数据内容。有了这些字典数据，我们就很容易的判断一个图片是否是文件资源了，如果是打包资源，也能够很容易找出打包资源所在的 Plist 文件和 图片文件，最后看一下 <code>createSprite</code> 方法的实现：</p>

<p>``` c++</p>

<pre><code>Sprite* AssetLoader::createSprite(const std::string&amp; name){
    if (AssetLoader::getInstance()-&gt;fileExists(name)){
        return Sprite::create(name);
    }
    log("create sprite: %s", name.c_str());
    std::string plistfile = AssetLoader::getInstance()-&gt;getTexturePlist(name);
    std::string imagefile = AssetLoader::getInstance()-&gt;getTextureImage(name);
    log("plist: %s, image: %s", plistfile.c_str(), imagefile.c_str());
    if (plistfile != "" &amp;&amp; imagefile != ""){
        SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile(plistfile, imagefile);
        return Sprite::createWithSpriteFrameName(name);
    }
    return nullptr;
}
</code></pre>

<p>```</p>

<p>至此我们便完成了 <strong>图片资源类型的 “透明化” 处理</strong> 。这样一个解决方案，很好的解决了在开发过程中图片资源的管理过程，后期优化，都不冲突。能够通过此提供一个较为合理的开发流程。 本文所使用的源码，脚本等都可以在 Github 上面找到 <a href="https://github.com/leafsoar/resource-manager">『https://github.com/leafsoar/resource-manager』</a>，但是要清楚，我这里提供的只是按照我这种流程下来的一种实现而已，对于程序本身而言，也还有很多可以改进的所在 ~ 思路同样，每个人实现的具体细节可能不一样，不论你使用 C++ 还是脚本语言，都不影响你 “透明化” 图片资源类型。</p>

<h2>如何优雅的管理游戏资源</h2>

<p>我们解决了一些问题，提供了一些解决方案，但总有更多的问题等着我们去解决，更多的优秀解决方案，好的工作模式，处理流程。我们会把开发中一些 <strong>变动</strong> 的所在找寻出来，对它灵活的处理，使它能够适应各种不同的 <strong>险恶环境</strong>。哪些是不变的，哪些是容易变动的，尽量做到 <strong>以不变应万变</strong>。现在新的问题和需求又来了，哈 ~</p>

<p>继续前文内容，我们可以使用 AssetLoader 来加载图片资源，创建精灵，实现游戏玩法逻辑等。但是我们通常会在一个场景进入时就预先缓存所有图片资源（声音资源亦是同样），甚至在游戏开始时，预先加载所有的图片资源，以 <strong>保证游戏画面的流畅性</strong>。如果没有预先缓存图片资源，那么在游戏中用到的时候，实时加载可能 <strong>会使游戏画面卡顿</strong>，这不是我们想看到的结果。如果一个游戏不大，资源总和也没多少，那么可以直接在游戏开始时全部加载完毕，这种情况处理起来比较简单，直接把所有资源加载就可以了。但是如今的游戏动辄几十兆，几百兆，显然游戏资源一次性加载是不科学的，这时我们可以分场景，在加载一个场景的时候，清空前一个场景所使用的图片缓存资源，然后预先加载当前场景的游戏资源，以达到最优的内存占用。</p>

<p>通常我们都是人为的，定义了一个方法在开始场景前做一些准备工作，清空缓存，预加载游戏资源，如这里有一个需要预加载的资源列表，而前文我们提到，在游戏开发的过程中，我们的图片资源可能会有所改动，这就需要我们去 <strong>人为的同步去手动维护这个列表</strong>，而这样的工作费时费力，还容易出现很多错误，如果我们能够把这一步的操作自动化，根据实际情况生成其列表，并且 <strong>列表资源的加载顺序也是做过优化的</strong>(根据文件大小，或者分辨率大小，优先加载大的资源，使游戏减少因占用内存过多而崩溃的可能性)，那将使我们能有 更多的精力花在更值得的地方。如果结合到本文之前的实现方案就是，在开始一个场景时，我们对 AssetLoader 做一个标记，在这个标记之后所请求的图片资源都是当前场景的资源，我们可以在内部将其记录下来，以任何方式都行，这样我们就能够非常容易的收集并生成当前场景所使用的图片资源了。如果我们将这个列表做成动态可维护的，自动记录以便下次运行时预先加载，这样一种实现从逻辑上来说时可行。如何优雅得管理游戏资源？但是实现比 优雅 更重要，在实现的过程中，尽量使开发变得简单，流程变得清晰，也是一叶努力的方向 ～</p>

<p>以上只是对预加载资源列表的动态维护，提供了一个简单的思路，其中还有很多细节值得推敲。但我想实现这样一种流程对游戏的开发是非常有帮助的，对于这个部分的内容，一叶还没有给出一个具体的实现方案，但将继续之前的流程往下实现，并分享在 Github 上面，同时你也可以参与进来。也算是在这里集思广益，如果你有什么好的想法，对本文实现有什么改进，都可以一起交流。如果你遇到了相同的问题，也可以说说你是怎么处理这些问题的，欢迎分享 ～</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本文源码 Github 仓库地址：<a href="https://github.com/leafsoar/resource-manager">https://github.com/leafsoar/resource-manager</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转 Cocos2d-x 脚本引擎]]></title>
    <link href="http://blog.leafsoar.com/archives/2013/11-10.html"/>
    <updated>2013-11-10T20:56:00+08:00</updated>
    <id>http://blog.leafsoar.com/archives/2013/script-engin</id>
    <content type="html"><![CDATA[<p>在 Unix 文化中，有这样一种理念，Happy Hacking！使用 Cocos2d-x/C++ 写过一些游戏，其绑定的脚本语言，用的也不少，脚本语言的一个好处就是快速开发，你无需明白它之运行机理，便可容易的完成所想要的效果，三天上手，五天就能写出像样的程序来，C++ 则不然，其各种语言细节特性，各种开发技巧，内存管理等细枝末叶 ~</p>

<p>计算机不会魔法，在一叶看来其内容，只有 <strong>“知、或者不知”</strong> ，没有 <strong>“懂、或者不懂”</strong>，“知或者不知”来自于你的学习历程与经验，至于“不懂”么，我还没接触到的领域内容，我都不懂，哈 ~ Cocos2d-x 脚本引擎也用过一段时间了，但其运行机理还不明白，就使用而言也无需明白，不过于在意细节的实现，可能更好的从宏观角度把握整体。过去只是对其“存疑”（对于这里的“不懂”，一叶通常美其名曰：<strong>要学会存疑</strong> :p ），而现在想要对其运行机制多了解一些，那就只有一步步去探究喽，要了解到什么程度，那就随意了～</p>

<p>对 Cocos2d-x 的运行机制只是略懂一二，C++ 的场景由 C++ 运行，脚本呢，先开启脚本引擎，让后将控制权交由脚本代码执行，在这过程中发生了什么，由脚本所控制的元素和 C++ 有什么不同，或者说它的本质是什么！这之前一叶一直说的是脚本引擎，而非具体那种脚本引擎，lua 或者 js (jsvascript)的引擎实现！凭着对已有知识的了解和直觉，很多疑问和可能性随之而来，它所支持的脚本语言有两种，此两种的共同之处是什么，其使用了脚本绑定技术，<strong>什么是绑定</strong> ？各种对象在内存中如何分布，如何配合在一起工作。</p>

<p>为了增加探究过程的趣味性，所以一叶试想着能不能让 Cocos2d-x 现今所支持的<strong>两种脚本引擎同时运行</strong> (lua and js)，然后确定是否能在三者之间（C++, js, lua）访问同一个内存元素，如果行，便弄出来，即便不能做到，那也无所谓，这其中的过程比结果更有意思，不是吗 ~</p>

<!-- more -->


<h2>两种脚本引擎同时运行</h2>

<p>这里使用了 cocos2d-x-3.0alpha0-pre 版本，原因有二。一者：这是最新版本，反正是折腾，顺便了解一下 3.0 的新特性和 代码 style ，其二：3.0 对 三大开发平台(windows, linux ,mac)，两大运行平台(android, ios)的支持更好更全一些，比如，lua 可以跑在 mac 上面，这一点最新的 2.2 版本不行（lua ）。这样的选择，可以让我在当前系统（Mac OS X） 系统下，直接运行看效果，而不用开模拟器或者虚拟机，使过程更为方便。（过去使用 Linux 作为开发环境，也很方便，一叶的博客也有其具体的开发环境搭建配置等）而 windows 系统，几年前就几乎不怎么用了，各种不顺手。</p>

<p>3.0 中去除了使用项目模板来构建项目，而改为使用脚本创建，支持的平台如下(这个脚本是 github 上最新的版本)，观其关键代码：</p>

<p>``` python</p>

<pre><code># [Cocos2d-x]/tools/project-creator/create_project.py
PLATFORMS = {
    "cpp" : ["ios_mac", "android", "win32", "linux"],
    "lua" : ["ios_mac", "android", "win32", "linux"],
    "javascript" : ["ios_mac", "android", "win32"]
}
</code></pre>

<p>```</p>

<p>从这里脚本看出 cpp 和 lua ，对五个平台已经全面支持，javascript 对 linux 还没有支持（脚本上是这样），相比 -x 2.x 版本支持更好，更全面，其代码也经过重构，更模块化，还有很多 C++ 11 的新特性，这里同样也期待 3.0 早日成熟，达到实用阶段 :p</p>

<p>为了简化操作步骤，一叶尽量利用现有的环境内容，使用 XCode打开 samples 项目，这里包含了所有项目内容，起初一叶打算基于 HelloCpp 项目做扩展，添加脚本支持，来实现自己的功能，也许是我对 XCode 环境了解不够，通过手动配置，让它能够支持 lua 扩展，但是 js 扩展却没能跑起来（没理由 lua 可以 js 却不行，知道一定是哪里配置有误），此时看来，在已有的项目中添加 lua 比 js 成功几率要大，固转而使用 HelloLua 项目添加 js 扩展支持，以达到项目组织上能够独立运行 js 引擎 或者 lua 引擎。（注：使用 HelloCpp 作为扩展，主要想看看怎么配置方便，如果都好配置，就基于 Cpp ，如果其中一个配置难，或者没通过，就基于没有通过配置的已有实现，扩展它。比如，这里 lua 通过 js 却没有，那就基于已有的 HelloLua 扩展支持 js，更为节省精力，这是策略问题 :p）</p>

<p>以上只是让项目同时支持 js <strong>或者</strong> lua 的运行，比如只跑 lua，或者只跑 js，但是 两者却不能同时跑，如果在代码中，同时用到了 lua 和 js 的支持库，在编译时会报错。这是因为在绑定的时候，两种脚本引擎分别实现了自己的 GLNode 。</p>

<p>``` c++</p>

<pre><code>// [Cocos2d-x]/scripting/javascript/bindings/js_bindings_opengl.h
#include "cocos2d.h"
#include "ScriptingCore.h"
#include "cocos2d_specifics.hpp"

class GLNode : public cocos2d::Node {
 public:
  void draw();
};

void js_register_cocos2dx_GLNode(JSContext *cx, JSObject *global);

// [Cocos2d-x]/scripting/lua/cocos2dx_support/LuaOpengl.h
#ifndef __LUA_OPENGL_H__
#define __LUA_OPENGL_H__

#ifdef __cplusplus
extern "C" {
#endif
#include "tolua++.h"
#ifdef __cplusplus
}
#endif

#include "base_nodes/CCNode.h"
class GLNode:public cocos2d::Node
{
    virtual void draw();
};

TOLUA_API int tolua_Cocos2d_CCDrawNode_drawPolygon00(lua_State* tolua_S);

TOLUA_API int tolua_opengl_open(lua_State* tolua_S);

#endif //__LUA_OPENGL_H__
</code></pre>

<p>```</p>

<p>同时使用两种引擎，就意味着同时用到两者的库依赖，而重复的类型定义导致编译通不过，所以只能根据需要 hack 源码了，如果修改，二者修改其一，看修改哪个方便，引用的地方少。如下是使用 Emacs 的 find-grep 命令，在 scripting 目录搜索 &ldquo;GLNode&rdquo; 关键字的结果。（Emacs 是一叶的必备工具，这里搜索出的结果可以快速定位代码位置）</p>

<p>```c++
&ndash;<em>&ndash; mode: grep; default-directory: &ldquo;~/Tools/cocos2d-x/cocos2d-x-3.0alpha0-pre/scripting/&rdquo; &ndash;</em>&ndash;
Grep started at Mon Nov 11 13:55:04</p>

<p>find . -type f -exec grep -nH -e GLNode {} +
./javascript/bindings/js/jsb_cocos2d_extension.js:167:cc.GLNode.extend = cc.Class.extend;
./javascript/bindings/js_bindings_opengl.cpp:3:void GLNode::draw() {
./javascript/bindings/js_bindings_opengl.cpp:27:JSClass  <em>js_cocos2dx_GLNode_class;
./javascript/bindings/js_bindings_opengl.cpp:28:JSObject </em>js_cocos2dx_GLNode_prototype;
./javascript/bindings/js_bindings_opengl.cpp:30:JSBool js_cocos2dx_GLNode_constructor(JSContext <em>cx, uint32_t argc, jsval </em>vp)
./javascript/bindings/js_bindings_opengl.cpp:34:    GLNode<em> cobj = new GLNode();
./javascript/bindings/js_bindings_opengl.cpp:41:    TypeTest<GLNode> t;
./javascript/bindings/js_bindings_opengl.cpp:51:    JS_AddNamedObjectRoot(cx, &amp;p->obj, &ldquo;cocos2d::GLNode&rdquo;);
./javascript/bindings/js_bindings_opengl.cpp:59:void js_cocos2dx_GLNode_finalize(JSFreeOp </em>fop, JSObject <em>obj) {
./javascript/bindings/js_bindings_opengl.cpp:62:static JSBool js_cocos2dx_GLNode_ctor(JSContext </em>cx, uint32_t argc, jsval <em>vp)
./javascript/bindings/js_bindings_opengl.cpp:65:    GLNode </em>nobj = new GLNode();
./javascript/bindings/js_bindings_opengl.cpp:68:    JS_AddNamedObjectRoot(cx, &amp;p->obj, &ldquo;GLNode&rdquo;);
./javascript/bindings/js_bindings_opengl.cpp:73:JSBool js_cocos2dx_GLNode_create(JSContext <em>cx, uint32_t argc, jsval </em>vp)
./javascript/bindings/js_bindings_opengl.cpp:75:  GLNode<em> ret = new GLNode();
./javascript/bindings/js_bindings_opengl.cpp:79:      js_proxy_t </em>proxy = js_get_or_create_proxy<GLNode>(cx, ret);
./javascript/bindings/js_bindings_opengl.cpp:91:void js_register_cocos2dx_GLNode(JSContext <em>cx, JSObject </em>global) {
./javascript/bindings/js_bindings_opengl.cpp:92:  js_cocos2dx_GLNode_class = (JSClass <em>)calloc(1, sizeof(JSClass));
./javascript/bindings/js_bindings_opengl.cpp:93:  js_cocos2dx_GLNode_class->name = &ldquo;GLNode&rdquo;;
./javascript/bindings/js_bindings_opengl.cpp:94:  js_cocos2dx_GLNode_class->addProperty = JS_PropertyStub;
./javascript/bindings/js_bindings_opengl.cpp:95:  js_cocos2dx_GLNode_class->delProperty = JS_PropertyStub;
./javascript/bindings/js_bindings_opengl.cpp:96:  js_cocos2dx_GLNode_class->getProperty = JS_PropertyStub;
./javascript/bindings/js_bindings_opengl.cpp:97:  js_cocos2dx_GLNode_class->setProperty = JS_StrictPropertyStub;
./javascript/bindings/js_bindings_opengl.cpp:98:  js_cocos2dx_GLNode_class->enumerate = JS_EnumerateStub;
./javascript/bindings/js_bindings_opengl.cpp:99:  js_cocos2dx_GLNode_class->resolve = JS_ResolveStub;
./javascript/bindings/js_bindings_opengl.cpp:100:  js_cocos2dx_GLNode_class->convert = JS_ConvertStub;
./javascript/bindings/js_bindings_opengl.cpp:101:  js_cocos2dx_GLNode_class->finalize = js_cocos2dx_GLNode_finalize;
./javascript/bindings/js_bindings_opengl.cpp:102:  js_cocos2dx_GLNode_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);
./javascript/bindings/js_bindings_opengl.cpp:109:      JS_FN(&ldquo;ctor&rdquo;, js_cocos2dx_GLNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
./javascript/bindings/js_bindings_opengl.cpp:114:    JS_FN(&ldquo;create&rdquo;, js_cocos2dx_GLNode_create, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
./javascript/bindings/js_bindings_opengl.cpp:118:  js_cocos2dx_GLNode_prototype = JS_InitClass(
./javascript/bindings/js_bindings_opengl.cpp:121:                         js_cocos2dx_GLNode_class,
./javascript/bindings/js_bindings_opengl.cpp:122:                         js_cocos2dx_GLNode_constructor, 0, // constructor
./javascript/bindings/js_bindings_opengl.cpp:129:  JS_SetPropertyAttributes(cx, global, &ldquo;GLNode&rdquo;, JSPROP_ENUMERATE | JSPROP_READONLY, &amp;found);
./javascript/bindings/js_bindings_opengl.cpp:132:  TypeTest<GLNode> t;
./javascript/bindings/js_bindings_opengl.cpp:139:    p->jsclass = js_cocos2dx_GLNode_class;
./javascript/bindings/js_bindings_opengl.cpp:140:    p->proto = js_cocos2dx_GLNode_prototype;
./javascript/bindings/js_bindings_opengl.h:5:class GLNode : public cocos2d::Node {
./javascript/bindings/js_bindings_opengl.h:10:void js_register_cocos2dx_GLNode(JSContext </em>cx, JSObject <em>global);
./javascript/bindings/jsb_opengl_registration.cpp:56:    js_register_cocos2dx_GLNode(_cx, ccns);
./javascript/bindings/obfuscate/obfuscate_exclude_cocos2d.js:3049:CSSProperties.prototype.GLNode;
./lua/cocos2dx_support/CCLuaEngine.cpp:615:    extendGLNode(lua_S);
./lua/cocos2dx_support/CCLuaEngine.cpp:726:void LuaEngine::extendGLNode(lua_State</em> lua_S)
./lua/cocos2dx_support/CCLuaEngine.cpp:731:    lua_pushstring(lua_S,&ldquo;GLNode&rdquo;);
./lua/cocos2dx_support/CCLuaEngine.cpp:736:        lua_pushcfunction(lua_S,tolua_Cocos2d_GLNode_registerScriptDrawHandler00);
./lua/cocos2dx_support/CCLuaEngine.cpp:739:        lua_pushcfunction(lua_S,tolua_Cocos2d_GLNode_unregisterScriptDrawHandler00);
./lua/cocos2dx_support/CCLuaEngine.h:146:    void extendGLNode(lua_State<em> lua_S);
./lua/cocos2dx_support/LuaOpengl.cpp:24:void GLNode::draw()
./lua/cocos2dx_support/LuaOpengl.cpp:26:    int handler = ScriptHandlerMgr::getInstance()&ndash;>getObjectHandler((void</em>)this, ScriptHandlerMgr::kGLNodeDrawHandler);
./lua/cocos2dx_support/LuaOpengl.cpp:38:    tolua_usertype(tolua_S, &ldquo;GLNode&rdquo;);
./lua/cocos2dx_support/LuaOpengl.cpp:42:static int tolua_collect_GLNode (lua_State<em> tolua_S)
./lua/cocos2dx_support/LuaOpengl.cpp:44:    GLNode </em>self = (GLNode<em>) tolua_tousertype(tolua_S,1,0);
./lua/cocos2dx_support/LuaOpengl.cpp:63:/</em> method: create of class  GLNode <em>/
./lua/cocos2dx_support/LuaOpengl.cpp:64:#ifndef TOLUA_DISABLE_tolua_Cocos2d_GLNode_create00
./lua/cocos2dx_support/LuaOpengl.cpp:65:static int tolua_Cocos2d_GLNode_create00(lua_State</em> tolua_S)
./lua/cocos2dx_support/LuaOpengl.cpp:70:        !tolua_isusertable(tolua_S,1,&ldquo;GLNode&rdquo;,0,&amp;tolua_err) ||
./lua/cocos2dx_support/LuaOpengl.cpp:77:        GLNode <em>glNode = new GLNode();
./lua/cocos2dx_support/LuaOpengl.cpp:83:            toluafix_pushusertype_ccobject(tolua_S, nID, pLuaID, (void</em>)glNode,&ldquo;GLNode&rdquo;);
./lua/cocos2dx_support/LuaOpengl.cpp:100:/<em> method: setShaderProgram of class  GLNode </em>/
./lua/cocos2dx_support/LuaOpengl.cpp:101:#ifndef TOLUA_DISABLE_tolua_Cocos2d_GLNode_setShaderProgram00
./lua/cocos2dx_support/LuaOpengl.cpp:102:static int tolua_Cocos2d_GLNode_setShaderProgram00(lua_State<em> tolua_S)
./lua/cocos2dx_support/LuaOpengl.cpp:107:        !tolua_isusertype(tolua_S,1,&ldquo;GLNode&rdquo;,0,&amp;tolua_err) ||
./lua/cocos2dx_support/LuaOpengl.cpp:115:        GLNode</em> self = (GLNode<em>)  tolua_tousertype(tolua_S,1,0);
./lua/cocos2dx_support/LuaOpengl.cpp:292:/</em> method: glBindFramebuffer of class  GLNode <em>/
./lua/cocos2dx_support/LuaOpengl.cpp:300:        !tolua_isusertype(tolua_S,1,&ldquo;GLNode&rdquo;,0,&amp;tolua_err) ||
./lua/cocos2dx_support/LuaOpengl.cpp:6386:      tolua_cclass(tolua_S,&ldquo;GLNode&rdquo;,&ldquo;GLNode&rdquo;,&ldquo;CCNode&rdquo;,tolua_collect_GLNode);
./lua/cocos2dx_support/LuaOpengl.cpp:6387:        tolua_beginmodule(tolua_S,&ldquo;GLNode&rdquo;);
./lua/cocos2dx_support/LuaOpengl.cpp:6388:            tolua_function(tolua_S, &ldquo;create&rdquo;, tolua_Cocos2d_GLNode_create00);
./lua/cocos2dx_support/LuaOpengl.cpp:6389:            tolua_function(tolua_S, &ldquo;setShaderProgram&rdquo;, tolua_Cocos2d_GLNode_setShaderProgram00);
./lua/cocos2dx_support/LuaOpengl.h:13:class GLNode:public cocos2d::Node
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:584:int tolua_Cocos2d_GLNode_registerScriptDrawHandler00(lua_State</em> tolua_S)
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:588:    if (!tolua_isusertype(tolua_S,1,&ldquo;GLNode&rdquo;,0,&amp;tolua_err) ||
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:595:        GLNode<em> glNode = (GLNode</em>)  tolua_tousertype(tolua_S,1,0);
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:597:        ScriptHandlerMgr::getInstance()&ndash;>addObjectHandler((void<em>)glNode, handler, ScriptHandlerMgr::kGLNodeDrawHandler);
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:608:int tolua_Cocos2d_GLNode_unregisterScriptDrawHandler00(lua_State</em> tolua_S)
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:612:    if (!tolua_isusertype(tolua_S,1,&ldquo;GLNode&rdquo;,0,&amp;tolua_err) ||
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:618:        GLNode<em> glNode = (GLNode</em>)tolua_tousertype(tolua_S,1,0);
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:619:        ScriptHandlerMgr::getInstance()&ndash;>removeObjectHandler((void<em>)glNode,ScriptHandlerMgr::kGLNodeDrawHandler);
./lua/cocos2dx_support/LuaScriptHandlerMgr.cpp:779:        tolua_constant(tolua_S,&ldquo;kGLNodeDrawHandler&rdquo;,ScriptHandlerMgr::kGLNodeDrawHandler);
./lua/cocos2dx_support/LuaScriptHandlerMgr.h:99:       kGLNodeDrawHandler,
./lua/cocos2dx_support/LuaScriptHandlerMgr.h:137:TOLUA_API int tolua_Cocos2d_GLNode_registerScriptDrawHandler00(lua_State</em> tolua_S);
./lua/cocos2dx_support/LuaScriptHandlerMgr.h:138:TOLUA_API int tolua_Cocos2d_GLNode_unregisterScriptDrawHandler00(lua_State* tolua_S);
./lua/script/Opengl.lua:297:    return GLNode:create()
Grep finished (matches found) at Mon Nov 11 13:55:07</p>

<p>```</p>

<p>目测感觉两者差不多，而且代码量也不多，所以修改其中之一的 GLNode 类名称是可行的，总共八十多行结果，修改一种就四十行左右，而且其中出现的 &ldquo;GLNode&rdquo; 关键字，并不是都需要修改，有的是绑定到脚本引擎内部的，我们只需要修改其 C++ 端绑定的类型就 OK 了，一叶修改了 lua 绑定中的 GLNode 名字为 LuaGLNode，然后定位到 LuaOpengl 和相关文件（两个文件左右），查找并替换其中一部分 &ldquo;GLNode&rdquo; 关键字代码，这里借助 Emacs ，递进式的关键字查询替换，通过匹配规则，一个个过滤，手动选择是替换还是不替换，最后替换了所有 C++ 中 Lua 端的 GLNode 类名实现（替换的内容很少，比我想象中要少）。</p>

<p>到这里就已经完成能够让两种脚本引擎同时运行的方法。并且一叶修改了入口函数，在 AppDelegate 入口处，添加修改：</p>

<p>```c++
bool AppDelegate::applicationDidFinishLaunching()
{</p>

<pre><code>// initialize director
Director *pDirector = Director::getInstance();
pDirector-&gt;setOpenGLView(EGLView::getInstance());

EGLView::getInstance()-&gt;setDesignResolutionSize(480, 320, ResolutionPolicy::NO_BORDER);

// turn on display FPS
pDirector-&gt;setDisplayStats(true);

// set FPS. the default value is 1.0/60 if you don't call this
pDirector-&gt;setAnimationInterval(1.0 / 60);
</code></pre>

<p>//    runLua();</p>

<pre><code>runCpp();
</code></pre>

<p>//    runJsb();</p>

<pre><code>return true;
</code></pre>

<p>}</p>

<p>void AppDelegate::runCpp(){</p>

<pre><code>auto scene = HelloLeafsoar::scene();
Director::getInstance()-&gt;runWithScene(scene);
</code></pre>

<p>}</p>

<p>void AppDelegate::runJsb(){</p>

<pre><code>ScriptingCore* sc = ScriptingCore::getInstance();
sc-&gt;addRegisterCallback(register_all_cocos2dx);
sc-&gt;addRegisterCallback(register_all_cocos2dx_extension);
sc-&gt;addRegisterCallback(register_cocos2dx_js_extensions);
sc-&gt;addRegisterCallback(jsb_register_chipmunk);
sc-&gt;addRegisterCallback(register_all_cocos2dx_extension_manual);
sc-&gt;addRegisterCallback(register_CCBuilderReader);
sc-&gt;addRegisterCallback(jsb_register_system);
sc-&gt;addRegisterCallback(JSB_register_opengl);

sc-&gt;start();

ScriptEngineProtocol *pEngine = ScriptingCore::getInstance();
ScriptEngineManager::getInstance()-&gt;setScriptEngine(pEngine);
ScriptingCore::getInstance()-&gt;runScript("main.js");
</code></pre>

<p>}</p>

<p>void AppDelegate::runLua(){</p>

<pre><code>LuaEngine* luaEngine = LuaEngine::getInstance();
ScriptEngineManager::getInstance()-&gt;setScriptEngine(luaEngine);

std::string path = FileUtils::getInstance()-&gt;fullPathForFilename("hello.lua");
luaEngine-&gt;executeScriptFile(path.c_str());
</code></pre>

<p>}</p>

<p>```</p>

<p>可以看到这里有三个方法，runCpp 、runLua 和 runJsb，这三者可单独独立运行，也可同时运行，在脚本实现不同的 log 打印，便能知晓，但如如果你在这三处同时运行了一个场景的话，那么根据场景的运行规则，后面运行的场景会入栈，替换之前场景的运行，三者的运行顺序，可以随意修改，并观其运行结果。为了测试这一点，我们同时运行 runLua、runCpp 和 runJsb ，然后使用一个全局定时器（请看 实现 <a href="http://blog.leafsoar.com/archives/2013/05-08.html">『Cocos2d-x 全局定时器』</a> 一文），每三秒钟弹出一个场景。而每一个场景的内部不同，这样我们便能看见首先运行了 runJsb 场景，三秒后 runLua ，之后 runCpp 场景，最终三秒后，所有场景弹出，Game Over 了。</p>

<h2>脚本绑定技术的特性</h2>

<p>以上通过对源代码的修改，一个例子，让 lua 和 js 两种脚本引擎同时运行，由于在任何时候只能有一个场景运行，所以，无论由 C++、lua 还是 js 来启动游戏，另外两种语言将会得不倒执行的权利，但是从另一个侧面，全局定时器它得的运行并不依赖场景的运行，这对我们研究程序执行过程中对象的特性提供了方便，前文通过一个 C++ 端实现的全局定时器，不论你运行的是不是脚本，是什么脚本，都不影响它之运行，那么我们就能能用这个定时器去定期的调用各种脚本，以让这三种脚本语言同时运行，在这样一个过程中，去验证对它们的内存分布，操作机制的的情况等 ~</p>

<p>一叶在 C++ 端开启了一个定时器，且由 C++ 运行了第一个场景，然后修改全局定时器的定时调用实现，添加对 lua 和 js 的脚本调用：</p>

<p>```c++
void GlobalSchedule::globalUpdate(float dt) {</p>

<pre><code>// 这里写全局定时器的逻辑处理代码
CCLOG("global update");
</code></pre>

<p>//    Director::getInstance()&ndash;>popScene();</p>

<pre><code>count ++;

auto scene = Director::getInstance()-&gt;getRunningScene();
LabelTTF* label = (LabelTTF*)scene-&gt;getChildByTag(100);
if (!label){
    label = LabelTTF::create("一叶 v 5~", "", 24);
    label-&gt;setPosition(Point(250, 300));
    label-&gt;setColor(Color3B::BLACK);
    scene-&gt;addChild(label, 1, 100);
} else {
    if (count % 3 == 0)
        label-&gt;setScale(1);
    else if (count % 3 == 1)
        ScriptingCore::getInstance()-&gt;runScript("jsbMethod.js");
    else if (count %3 == 2)
        LuaEngine::getInstance()-&gt;executeScriptFile("luaMethod.lua");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这是全局定时器的实现，它在当前运行的场景中添加了一个 Label ，label 的内容 &ldquo;<strong>一叶 v 5~</strong>"，并且通过一个执行技术 <strong>count</strong> 来决定当前执行的是 C++ 还是 lua 或者 js，在不同的语言中，修改同一个元素的大小 <strong>Scale</strong>，看看 js 和 lua 的 method 文件实现：</p>

<p>```lua
&mdash; luaMethod.lua 具体实现
cclog = function(&hellip;)</p>

<pre><code>print(string.format(...))
</code></pre>

<p>end</p>

<p>cclog(&ldquo;lua method .&rdquo;);</p>

<p>local scene = CCDirector:getInstance():getRunningScene()
local label = scene:getChildByTag(100)
label:setScale(0.8)</p>

<p>```</p>

<p>```javascript
// jsbMethod.js 具体实现
cc.log(&ldquo; jsb method .&rdquo;);</p>

<p>var scene = cc.Director.getInstance().getRunningScene();
var label = scene.getChildByTag(100);
label.setScale(1.2);</p>

<p>```</p>

<p>以上的代码都很简单，各种语言的逻辑一样，首先或者当前运行着的场景，然后通过 tag 获取场景中的元素 Label，再之修改它的大小，这样将程序运行，便能看见此 Label 定时改变大小，而且是三种大小状态不停的切换，可见已经完成了我们之前的目标，双开脚本引擎，用不语言控制同一个元素（文章最后给出所有代码）。</p>

<h3>绑定技术的特性浅析</h3>

<p>说道脚本绑定技术，这里可以插入一个新的内容来说，Cocos2d-html5 版本！作为对比，更为明了，h5 的实现和 jsb 的实现显然不同，h5 是跑在浏览器上的，jsb 是跑在移动终端上的。但是它们都用统一的接口实现，即用 js 写的游戏（同一套代码）即能够跑在浏览器上，又能够能跑在手机的 js 引擎上，这两者之间 <strong>表面相同，本质不同 </strong>，也是隐藏了内部实现，提供统一的接口让写程序更为简单。有兴趣的朋友可以去了解一下。在 Emacs 内置的 lisp 语言函数中有很多性能要求比较高的是使用 c 语言实现的，但在调用的时候全然不知（不知道就对了）。</p>

<p>而 jsb 和 lua 之间：知其不同，是见其表，知其皆同，是知其本，舍不同而观其同，可游心于物之初，哈。 在脚本引擎库中，以 C++ 实现的类型为基本，通过动态往虚拟机（引擎环境，或者上下文对象）里添加类型定义并绑定，每钟脚本类型都有其对应的 C++ 类型作为依据，通过脚本创建的对象最终被映射为调用 C++ 创建对象，而在 C++ 中创建的对象，也可以在脚本中随时获取，并修改其属性，当然其内部还有复杂的内存管理解决方案 (特别是本文中这样混合形的运行时环境，其对象生命周期就更复杂了，关系到引擎内部实现的细节，由不同语言创建的对象，由谁管理，由谁释放等等)，在需要之时可以深究，而这里显然没有必要（这里引擎双开仅作学习之用），宏观角度考量，内存管理无非是定义一套规则，或是规范，这样能保证出错误的最小可能性（在 <a href="http://blog.leafsoar.com/archives/2013/05-22.html">『Cocos2d-x 内存管理浅说』</a> , <a href="http://blog.leafsoar.com/archives/2013/05-29.html">『Cocos2d-x 内存管理的一种实现』</a>, <a href="http://blog.leafsoar.com/archives/2013/06-04.html">『深入理解 Cocos2d-x 内存管理』</a>) 几篇文章有怎样通过编程规范来尽量避免内存出现的问题）。</p>

<p>如果我们需要添加一种新脚本绑定实现，比如使用 lisp 语言作为绑定 （Emacs 用户首先想到的就是 lisp 了），那么我们需要一个 lisp 运行时环境的实现，然后通过函数绑定，javascript 和 lua 的第一类型是 函数（First-class Function），它们都有很强的函数式语言特性，其封装的 Cocos2d-x 调用方式不过是语法糖衣，看起来像面相对象而已，此点 js 表现更甚。所以对于 lisp 实现来说，是可行的，至于最后写起来是否顺手不得而知，目测如果实现，写法更像 lua 对 Cocos2d-x 的 style，可能很好使，可能很糟糕 :P 也许使用对象形的脚本语言更加合宜。</p>

<h2>非吾小天下 宏观而已</h2>

<p>想要玩转这里脚本引擎，那么你至少会绑定，知道怎么绑定，其具体步骤 ？jsb 怎么手动绑定，lua 怎么手动绑定，而且还有自动绑定脚本，jsb 的内部使用了 spidermonkey 开源的 js 引擎，lua 还可以开 jit，其运行环境有很多复杂的上下文参数，各种错综复杂，提出各种专有的概念，有着各自不同的游戏规则，其内部的细枝末叶是对具体问题的解决方案，然而有的时候我们并不知道需要解决的问题由来，一环套着一环，我在这里却避而不谈，一方面是因为我也不知 :p ,另一方面是因为不想让我或者别人陷入这样那样的泥沼中去，从宏观的角度去看问题，或者抽象，在 lua 和 js 这两种脚本引擎中，其特点为何，能达到什么样的效果，在本文的操作过程，并没有什么复杂的步骤，修改了一处编译报错问题，引擎双开，操作同一对象。避开了很多各脚本的内部实现细节内容。把复杂的问题简单化 ~</p>

<p>关于本文的内容，一叶会将代码项目提交到 github 以供参考（在文章最后给出<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>），内容不多，组织凌乱（时不时想修改，临时添加以看不同的测试效果），所以就将就着看了，哈，我的博文从不倾向给出一个完整的解决方案，以思路为重，其过程比结果更为重要。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>本文环境及其代码：<a href="https://github.com/leafsoar/cocos2d-x-script-engine">https://github.com/leafsoar/cocos2d-x-script-engine</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CCScrollView 实现帮助界面、关卡选择]]></title>
    <link href="http://blog.leafsoar.com/archives/2013/07-27.html"/>
    <updated>2013-07-27T17:30:00+08:00</updated>
    <id>http://blog.leafsoar.com/archives/2013/ccscrollview-level</id>
    <content type="html"><![CDATA[<p>本文介绍了 CCScrollView 来编写帮助界面和关卡选择界面的方法，在编写这样一个功能之时，大多会遇到一些困难，这里也是同样，最后提供了一个相应且合理的解决方案，并解说了其它实现方案的优缺点，这里的内容，你可以直接拿去用，或者可以作为实现的参考。总能找到你需要的东西，或多～或少～。文章大致内容如下：</p>

<ul>
<li>首先实现了一个可拖动的界面，滚屏屏幕，它可以用于完成帮助界面的设计</li>
<li>接着实现了关卡选择功能，这里的着重点是 <strong>如何处理触摸机制</strong> 。以达到不错的协同工作</li>
<li>由于是分屏滚动，所以完成了一个页索引 “指示球功能”</li>
</ul>


<p>本文所使用的 Cocos2d-x 为当前的稳定版本 2.1.4。（如无说明，文章内容总是配合 当前最新 稳定版库）
原来是使用 Cocos2d-x 2.0.4 编写的功能，周末花了点事件进行了整理 和 重构（触摸机制的重构）。</p>

<!-- more -->


<hr />

<h2>可拖动界面的实现 （帮助界面）</h2>

<p>实现帮助界面，那么我们首先要考虑的是，我们需要一个什么样的效果？大致总结如下：</p>

<ul>
<li>一个可分屏显示的界面是必须的</li>
<li>界面可以拖动操作，多屏滚动</li>
<li>还想添加一个滚动屏幕的校队，以使显示区域正好是屏幕宽度的倍数</li>
</ul>


<p>现在我们将要使用 CCScrollView 来实现这么样一个功能，那么它需要哪些 <strong>元素</strong> 以及需要解决哪些设计上的问题，整理一下思路先：</p>

<ul>
<li>首先需要一个 CCScrollView 层，和一个包含内容的容器层（CCLayer）</li>
<li>处理触摸操作，我们直接启用 CCScrollView 的可触摸操作，就已经能够完成对 CCScrollView 的拖动，这是它本身所提供的功能</li>
<li>CCScrollView 本身所提供的触摸操作，默认情况有诸多不便，虽然能够拖动，但区域控制器来确很繁琐，更何况我们还需要校队，对齐等操作</li>
<li>所以我们将 触摸 的操作交由 CCScrollView 所在的层（或者当前运行的场景），禁用 CCScrollView 的触摸，我们通过处理当前界面的触摸，用以控制 CCScrollView 的行为，是一个可行的解决方案</li>
</ul>


<p>下面给出相应的关键代码，实现以上功能（本文的示例都在此处 <a href="https://github.com/leafsoar/ls-cocos2d-x/blob/master/MacCpp/Classes/LevelView.cpp">源码查看</a>）：</p>

<p>``` c++</p>

<pre><code>// 创建一个 CCScrollView, 内容大小和当前的界面一样
CCScrollView* scrollView = CCScrollView::create(this-&gt;getContentSize());
// 设定容器层，我们并不需要重新设置 scrollview 的 ContentSize，容器层内部设定即可
scrollView-&gt;setContainer(getContainLayer());
// 关闭 scrollView 的可触摸操作
scrollView-&gt;setTouchEnabled(false);

// 容器层内容实现
CCLayer* LevelView::getContainLayer(){
    m_nPageCount = 4;

    CCSize winSize = CCDirector::sharedDirector()-&gt;getWinSize();
    CCPoint pointCenter = ccp(winSize.width / 2, winSize.height / 2);

    CCLayer* layer = CCLayer::create();
    layer-&gt;setPosition(CCPointZero);

    // 添加 frame，每 一页 用一张背景图显示
    for (int i = 0; i &lt; m_nPageCount; i++) {
        CCSprite* frame = CCSprite::create("level/frame.png");
        frame-&gt;setPosition(ccpAdd(pointCenter, ccp(winSize.width * i, 0)));
        layer-&gt;addChild(frame);
    }

    layer-&gt;setContentSize(CCSizeMake(winSize.width * m_nPageCount, winSize.height));

    return layer;
}
</code></pre>

<p>```</p>

<p>完成以上内容，那么基本准备工作就做好了。上面我们要注意区分两个概念，ViewSize 和 ContentSize，ViewSize 是 scrollView 所显示区域的大小，ContentSize 是滚动层的区域大小，一般而言，ViewSize 就是 ContentSize 上可见的一部分区域，通过拖动可以显示不同的部分。</p>

<p>后面继续，触摸处理相关代码：</p>

<p>``` c++</p>

<pre><code>// 关闭 scrollview 的触摸，相应的，我们要启用当前的触摸，并注册为单点触摸类型
void LevelView::registerWithTouchDispatcher(){
    CCDirector::sharedDirector()-&gt;getTouchDispatcher()-&gt;addTargetedDelegate(this, 0, true);
}

bool LevelView::ccTouchBegan(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent){
    // 记录触摸起始点的位置
    m_touchPoint = CCDirector::sharedDirector()-&gt;convertToGL(pTouch-&gt;getLocationInView());
    // 记录触摸起始点的偏移
    m_touchOffset = getScrollView()-&gt;getContentOffset();
    return true;
}

void LevelView::ccTouchMoved(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent){
    CCPoint movePoint = CCDirector::sharedDirector()-&gt;convertToGL(pTouch-&gt;getLocationInView());
    // 获得当前的拖动距离
    float distance = movePoint.x - m_touchPoint.x;

    // 设定当前偏移位置
    CCPoint adjustPoint = ccp(m_touchOffset.x + distance, 0);
    // 让 scrollView 跟着 move 操作而移动
    getScrollView()-&gt;setContentOffset(adjustPoint, false);
}

void LevelView::ccTouchEnded(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent){
    CCPoint endPoint = CCDirector::sharedDirector()-&gt;convertToGL(pTouch-&gt;getLocationInView());
    float distance = endPoint.x - m_touchPoint.x;

    if (fabs(distance) &lt; 3){
        // 小于三，不做拖动操作，也排除了（抖动误操作）
    }else if (fabs(distance) &gt; 50){
        // 大于 50，执行拖动效果
        adjustScrollView(distance);
    }else{
        // 回退为拖动之前的位置
        adjustScrollView(0);
    }
}

void LevelView::ccTouchCancelled(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent){
    // 参数为 0 表示 恢复之前的屏幕位置
    adjustScrollView(0);
}

void LevelView::adjustScrollView(float offset){
    CCSize winSize = CCDirector::sharedDirector()-&gt;getWinSize();
    // 我们根据 offset 的实际情况来判断移动效果
    if (offset &lt; 0)     // 表示右移
        m_nCurPage ++;
    else if (offset &gt; 0)
        m_nCurPage --;

    // 屏幕 页数 检测
    if (m_nCurPage &lt; 0)
        m_nCurPage = 0;
    else if (m_nCurPage &gt; m_nPageCount - 1)
        m_nCurPage = m_nPageCount - 1;

    // 根据当前的 页数 获得偏移量，并设定新的位置，且启用动画效果
    CCPoint adjustPoint = ccp(-winSize.width * m_nCurPage , 0);
    getScrollView()-&gt;setContentOffsetInDuration(adjustPoint, 0.2f);

    CCLog("current page index: %d", m_nCurPage);
}
</code></pre>

<p>```</p>

<p>由以上的内容，便完成了我们所需要的帮助界面的效果，一个可拖动，滚动的界面，页面数根据自己需要来定，这里只是实现的步骤，当然在这个界面里面要放什么元素，那就要看你的心情了，哈！</p>

<p>要放什么元素？我们基于以上的实现，在里面添加可点击项，以完成一个关卡选择功能！</p>

<hr />

<h2>扩展，实现关卡选择功能</h2>

<p>关卡选择 就界面而言，和上面所说的帮助界面并没有太大区别，所不同的是，除了触摸拖动界面之外，还可以点击内部的元素，如关卡，以实现不同的功能，所以我们基于以上的内容，扩展添加实现关卡选择功能。</p>

<p>实现以下代码，完成在界面添加关卡精灵元素：</p>

<p>``` c++</p>

<pre><code>// 修改层内容实现
CCLayer* LevelView::getContainLayer(){
    m_nPageCount = 4;
    // ..... 此处省略，参照上文

    // 在此处添加关卡精灵
    for (int i = 0; i &lt; levelCount; i ++) {
        CCNode* level = getSpriteByLevel(i);
        // 设置位置
        int curPageIndex = i / (widthCount * heightCount);
        float xOffset = i % 4 * 100 + 90;
        float yOffset = winSize.height - ((i % (widthCount * heightCount)) / widthCount * 120 + 180);

        level-&gt;setPosition(ccp(xOffset + winSize.width * curPageIndex, yOffset));
        // 这里使用了 zOrder = 2，用此值来构建层次关系，如后文将要添加的显示点击背景效果
        layer-&gt;addChild(level ,2, i);
    }

    return layer;
}

// 这里是上面所用到的方法
CCNode* LevelView::getSpriteByLevel(int level){

    CCSprite* sprite = CCSprite::create("level/level.png");
    // 添加关卡标示
    CCString* str = CCString::createWithFormat("%d", level + 1);
    CCLabelBMFont* label = CCLabelBMFont::create(str-&gt;getCString(),"level/prim30.fnt");
    label-&gt;setPosition(ccp(40, 45));
    sprite-&gt;addChild(label);

    // 这里可以再为 关卡精灵做些装饰，就像 lable 一样，如样式，关卡锁等其它元素

    return sprite;
}
</code></pre>

<p>```</p>

<p>写到这里，我们就完成了所有的显示效果，并且可以拖动界面显示不同的页，还有关卡选择的精灵，不过现在还欠缺的就是，关卡点击的操作了！要实现一个可点击操作的功能，我们可以有以下几种常用的方式：</p>

<ul>
<li>使用 CCMenu 来作为点击项的操作：一般而言，一叶不喜欢使用 CCMenu，因为它的触摸时机不好控制，特别是在当前界面可拖动的情况，还有些冲突，解决起来也挺麻烦，一个显著的影响是，点击 CCMenu 的时候，拖动滚屏就失去了效果，如果你有精力着折腾使用 CCMenu ,那么无妨～</li>
<li>使用常用精灵，以容器层接受触摸消息，然后依次遍历精灵，条件判断是否产生点击项，这是一个常用的方法，需要设定好一系列集合，遍历，判断等复杂的步骤，特别是类似方块游戏中用的挺多，总乐此不疲～话说一叶之前也是这么实现的！但是实现起来也时相当麻烦的～而且编写的逻辑不能够被重用（其它游戏类似功能）</li>
<li>建立一套新的机制，来满足特性情况下的需求，也就是封装一套解决方案，以方便对诸如此类的操作，这让一叶想到了之前的文章 《<a href="http://blog.leafsoar.com/archives/2013/05-25.html">多层 UI 触摸事件的轻量级设计</a>》（这种设计能够适应大多情况，正好用在此处，看看它的实用性如何！），在写这篇文章的时候，也将此处的操作用这样的机制重构一番。</li>
</ul>


<hr />

<h3><strong>基于 LsTouch 的触摸机制实现</strong></h3>

<p>在阅读以下内容之前，可以先看《<a href="http://blog.leafsoar.com/archives/2013/05-25.html">多层 UI 触摸事件的轻量级设计</a>》一文，里面详细介绍了它的实现机制，以及特性，可以简称它为 <strong>LsTouch</strong>，而此文是将这种设计用在可用之处。当然作为封装来说，你并不需要了解它的内部实现，就能够很好的使用它。或者换句话说，作为封装的模块，你只需要知道，如下这样使用它就行，它能帮我们解决触摸操作的问题，如果对内部实现感兴趣，可以去看一看实现。它的步骤如下。</p>

<p> 继承 <strong>LsTouchEvent</strong> 并实现 <strong>touchEventAction</strong> 接口函数，这样做以后将意味着，你可以在这个类中使用 <strong>addLsTouch</strong> 方法添加 “可触摸” 元素，其自动管理，之后可以在任意地方调用 <strong>sendTouchMessage</strong> 方法（它将会传入当前的点击 pTouch 参数），后自动回调 touchEventAction 方法，回调参数将包含了，当前的 “可触摸” 元素的引用，你因此知道，你点击的是哪个元素（如 哪个关卡）。以下用代码来说明其实现（我们将旧代码注释，以体现所改动的地方）：</p>

<p>``` c++</p>

<pre><code>// 继承 LsTouchEvent 并实现接口函数
void LevelView::touchEventAction(LsTouch *touch, int type){
    if (touch)
        CCLog("touch event action id: %d  type: %d", touch-&gt;getEventId(), type);
}

// 改写上文，返回精灵函数，使之变为可操作项
CCNode* LevelView::getSpriteByLevel(int level){

    // CCSprite* sprite = CCSprite::create("level/level.png");
    // // 添加关卡标示
    // CCString* str = CCString::createWithFormat("%d", level + 1);
    // CCLabelBMFont* label = CCLabelBMFont::create(str-&gt;getCString(),"level/prim30.fnt");
    // label-&gt;setPosition(ccp(40, 45));
    // sprite-&gt;addChild(label);
    // // 这里可以再为 关卡精灵做些装饰，就像 lable 一样

    // 可以看到改动的地方不多，这样就把需要显示的精灵，包装成了可操作项
    LsTouch* touch = LsTouch::create();
    touch-&gt;setDisplay(sprite);
    // 可触摸项添加到可触摸项集合，关卡 level 作为 eventId 传递
    this-&gt;addLsTouch(touch, level);

    return touch;
}

// 在触摸函数里面添加，发送触摸消息，只需要添加一句话
bool LevelView::ccTouchBegan(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent){
    // CCLog("touch begin.");
    // m_touchPoint = CCDirector::sharedDirector()-&gt;convertToGL(pTouch-&gt;getLocationInView());
    // m_touchOffset = getScrollView()-&gt;getContentOffset();

    // 发送触摸消息，并会在 touEventAction 自动相应， 如果触摸到元素
    sendTouchMessage(pTouch, 0);

    return true;
}

// 这里也是同样
void LevelView::ccTouchEnded(cocos2d::CCTouch *pTouch, cocos2d::CCEvent *pEvent){
    // CCPoint endPoint = CCDirector::sharedDirector()-&gt;convertToGL(pTouch-&gt;getLocationInView());
    // float distance = endPoint.x - m_touchPoint.x;
    // float distanceY = endPoint.y - m_touchPoint.y;
    //if (fabs(distance) &lt; 3 &amp;&amp; fabs(distanceY) &lt; 3){
        // 小于三，不做拖动操作，也排除了（抖动误操作）,第二个参数，事件类型 1： touch end， 由 touchEventAction 自动响应
        sendTouchMessage(pTouch, 1);
    //
    //}else if (fabs(distance) &gt; 50){
    //    // 大于 50，执行拖动效果
    //    adjustScrollView(distance);
    //}else{
    //    // 回退为拖动之前的位置
    //    adjustScrollView(0);
    //}

    // 无论如何，触摸结束，类型为 2
    sendTouchMessage(pTouch, 2);
}
</code></pre>

<p>```</p>

<p>上文，我们对 getSpriteByLevel 所返回的精灵做了包装处理，然后在 ccTouch 函数，调用发送触摸消息，然后自动回调 <strong>touchEventAction</strong> 函数，并带回了点击项的参数，这个点击项就包含了关卡信息 eventId ，还扩展了事件类型，表示是在 ccTouchBegin 还是 ccTouchEnd 种调用的，并依次做相应的逻辑操作。</p>

<p>下面具体实现回调函数的逻辑处理，它实现了点击项高亮显示，点击成功时通过 CCMessageBox 弹出提示：</p>

<p>``` c++</p>

<pre><code>void LevelView::touchEventAction(LsTouch *touch, int type){
    // type 事件类型，0：touchbegin 1：touchend 触发 2：touchend 未触发
    if (touch)
        CCLog("touch event action id: %d  type: %d", touch-&gt;getEventId(), type);
    int selectTag = 10001;
    if (type == 0 &amp;&amp; touch){
        getScrollView()-&gt;getContainer()-&gt;removeChildByTag(selectTag);
        // 添加选撞状态的精灵，背景 高亮显示
        CCSprite* sprite = CCSprite::create("level/sel.png");
        sprite-&gt;setScaleX(2);
        sprite-&gt;setScaleY(4);
        sprite-&gt;setPosition(touch-&gt;getPosition());
        // 这里使用了 zOrder = 1 以保证，高亮图片显示在 实际关卡图片后面
        getScrollView()-&gt;getContainer()-&gt;addChild(sprite, 1, selectTag);

    } else {
        getScrollView()-&gt;getContainer()-&gt;removeChildByTag(selectTag);
    }
    if (type == 1 &amp;&amp; touch){
        // 收到 type 为 1 表示触发关卡选择
        CCString* str = CCString::createWithFormat("您选择的关卡为 %d .", touch-&gt;getEventId() + 1);
        CCMessageBox("关卡", str-&gt;getCString());
    }
}
</code></pre>

<p>```</p>

<p>这里的 LsTouch 根据实际情况 比 原来（原来是指《<a href="http://blog.leafsoar.com/archives/2013/05-25.html">多层 UI 触摸事件的轻量级设计</a>》）做了些改进。</p>

<ul>
<li>内部判断去除了一些不必要的判断</li>
<li>修改消息类型，添加 type 参数，我们可以根据次参数判断消息类型</li>
<li>修改 touchEventAction 为总是回调（在发送消息时），而原来的做法是，这样做的好处是我们可以根据第一个参数是否为空，来做一些处理，而原来只在有点击操作才回调</li>
</ul>


<p>关于这里使用继承 LsTouchEvent 实现 touchEventAction 回调函数的方式，需要简单说明以下，这里设计的核心是使用一个集合管理一推“可触摸”项。至于我用什么方式实现，那不重要，例如换种设计，不用继承实现接口，使用 回调函数绑定，就像绑定 CCMenu 回调一样，如果 C++ 能够像 Java 编写匿名类实现回调，那就更优雅了～实现要 “<strong>达到可用简单，通用难！</strong>”，这里只是一种可行方案。</p>

<hr />

<h2>锦上添花，添加当前页指示球</h2>

<p>当前界面的所有功能已经实现完毕，如果使用它们，你需要注意一些地方，比如关卡精灵可以根据自己需要扩展其元素内容等。由于时滚动分页，为了一目了然我们当前的页，所以也添加了代码实现在屏幕上方设定了 <strong>页数指示球</strong>（我给起的名），指示球会在你拖动界面的时候有动态效果，放大当前 页数的指示球，给予更好的用户体验，关于这部分代码我就不贴了，可以直接从源码里面看见，方法名为 <strong>setCurPageBall</strong>，它会根据总页数和当前页数自动处理，你所需要做的只是在合适的时候调用它即可。</p>

<p>注意：为了让问题更有针对性，在本文中所有的位置关系所参考的都是 WinSize，
这意味着，如果你在不同的屏幕适配方案中可能需要有所改动，对屏幕适配这里有一篇文章可以作为参考《<a href="http://blog.leafsoar.com/archives/2013/05-10.html">Cocos2d-x 屏幕适配新解</a>》。</p>

<p><img src="/images/2013/2013-07-27-1.jpg" alt="图片" /></p>

<p>它完成了以下几个功能（<a href="https://github.com/leafsoar/ls-cocos2d-x/blob/master/MacCpp/Classes/LevelView.cpp">示例源码</a>）：</p>

<ul>
<li>帮助界面功能的实现：一个可拖动滚屏的界面展示</li>
<li>实现滚屏的自动校队，一页一页展示</li>
<li>关卡点击事件处理，实现关卡功能</li>
<li>选中关卡的高亮显示，背景标示</li>
<li>由于没有使用 CCMenu ，所以不存在触摸优先级问题，在点击 “关卡” 的同时可拖动屏幕</li>
<li>点击抖动误操作判断（如本来想点击关卡，如果移动了位置[移动范围大于指定值]，那么将执行拖动操作）</li>
<li>当前页指示球功能</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解 Cocos2d-x 内存管理]]></title>
    <link href="http://blog.leafsoar.com/archives/2013/06-04.html"/>
    <updated>2013-06-04T10:50:00+08:00</updated>
    <id>http://blog.leafsoar.com/archives/2013/cocos2dx-mem</id>
    <content type="html"><![CDATA[<p>如果 <a href="http://blog.leafsoar.com/archives/2013/05-22.html">Cocos2d-x 内存管理浅说</a> 做为初步认识，而 <a href="http://blog.leafsoar.com/archives/2013/05-29.html">Cocos2d-x 内存管理的一种实现</a>做为进阶使用，那么本文将详细的分析一下 Cocos2d-x 的内存管理的设计实现和原理。<strong>知其然，知其所以然 ~</strong>或者说：嗯，它这么做，一定是有原因的，体会设计者的用意，感同身受，如果是你，将会如何设计！~~</p>

<p>我觉得 <strong>最好的学习方式是以自己的语言组织，说与别人听 ～</strong> 这样对自己：更容易发现平时容易忽略的问题，对别人：或多或少也有所助益！以学习为目的，而别人的受益算是附带的效果，这样一个出发点 ~</p>

<p>由浅入深，总览全局（或者由整体到局部）是我喜欢的出发点，或者思考角度，我不喜欢拘泥于细节的实现，因为那会加大考虑问题的复杂度，所以 <strong>把复杂的问题简单化，是必然的过程。</strong> 那么本文就说说 Cocos2d-x 的架构是如何设计以方便内存管理的。从理论到实践 ~(当然是从我看问题的角度 :P，读者如有异议，欢迎讨论！文本使用 cocos2d-x 2.0.4 解说。)</p>

<!-- more -->


<hr />

<h2>引用计数的由来</h2>

<p>cocos2d-x 的世界是基于 <strong>CCObject</strong> 类构建的，其中的每个元素：层、场景、精灵等都是一个个 CCObject 的对象。所以 <strong>内存管理的本质就是管理一个个 CCObject</strong>。作为一个 cocos2d 的 C++ 移植版本，在它之前有很多其它语言的 <strong>实现</strong>，从架构层次来说，这与语言的实现无关（比如 CCNode 的节点树形关系，其它语言也可以实现，如果是内存方便，C# 等更是无需考虑），但就从内存管理方面来说，参考了 OC （Objective-C） 的内存管理实现。</p>

<p>一个简单的<strong>自动管理原则</strong>：<strong>CCObject 内部维护着一个引用计数，引用计数为 0 就自动释放 ～</strong>（如果么有直接做如 delete 之类的操作）。那么此时可以预见，<strong>管理内存的实质就是管理这些 &ldquo;引用计数&rdquo; </strong> 了！使用 retain 和 release 方法对引用计数进行操作！</p>

<hr />

<h2>为什么要有自动释放池 及其作用</h2>

<p>我们知道 cocos2d-x 使用了自动释放池，自动管理对象，知其然！其所以然呢？<strong>为什么需要自动释放池</strong>，它在整个框架之中又起着什么样的作用！在了解这一点之前，我们需要 <strong>知道 CCObject 从创建之初，到最终销毁</strong>，经历了哪些过程。在此，一叶总结以下几点：</p>

<ul>
<li>刚创建的对象，而 <strong>为了保证在使用之前不会释放</strong>（至少让它存活一帧），所以<strong>自引用</strong>（也就是初始为1）</li>
<li>为了确定是否 <strong>实际使用</strong>，所以需要在一个合适的时机，<strong>解除自身引用。</strong></li>
<li>而这个何时的时机正是在<strong>帧过度之时。</strong></li>
<li>帧过度之后的对象，<strong>用则用矣，不用则弃！</strong></li>
<li>由于已经解除了自身引用，所以它的<strong>引用被使用者管理</strong>（一般而言，内部组成树形结构的链式反应，如 CCNode）。</li>
<li>链式反应，也就是，如果释放一个对象，也会释放它所引用的对象。</li>
</ul>


<p>上面是一个对象的大致流程，我们将对象分为<strong>两个时期</strong>，一个是刚<strong>创建时期</strong>，自引用为 <strong>1</strong>（如果为 0 就会释放对象，这是基本原则，所以要大于 0） 的时期，另一个是<strong>使用时期</strong>。上面说到，为了保证创建时期的对象不被销毁，所以自引用(<strong>并没有实际的使用</strong>)初始化为 1，这就意味着我们需要一个合适的时机，来解除这样的自引用。</p>

<p><strong>何时？</strong>在帧过度之时！(这样可保证当前帧能正确使用对象而没有被销毁。)<strong>怎么样释放？</strong>由于是自引用，我们并不能通过其它方式访问到它，所以就有了自动释放池，我们 <strong>变相的将“自引用”转化“自动释放池引用”，来标记一个 “创建时期的对象”</strong>。然后在帧过度之时，通过自动释放池管理，统一释放 “释放池引用”，也就意味着，去除了“自身引用”。<strong>帧过度之后的对象，才是真正的被使用者所管理。</strong> 下面我们用代码来解释上述过程。</p>

<p>通常我们使用 <code>create();</code> 方法来创建一个自动管理的对象，而其内部实际操作如下：</p>

<p>``` c++</p>

<pre><code>// 初始化一个对象
static CCObject* create() 
{
    // new CCObject 对象
    CCObject *pRet = new CCObject(); 
    if (pRet &amp;&amp; pRet-&gt;init()) 
    {
        // 添加到自动释放池
        pRet-&gt;autorelease(); 
        return pRet; 
    } 
    else 
    { 
        delete pRet; 
        pRet = 0; 
        return 0; 
    } 
}

// 我们看到初始化的对象 自引用 m_uReference = 1
CCObject::CCObject(void)
:m_uAutoReleaseCount(0)
,m_uReference(1) // when the object is created, the reference count of it is 1
,m_nLuaID(0)
{
    static unsigned int uObjectCount = 0;

    m_uID = ++uObjectCount;
}

// 标记为自动释放对象
CCObject* CCObject::autorelease(void)
{
    // 添加到自动释放池
    CCPoolManager::sharedPoolManager()-&gt;addObject(this);
    return this;
}

// 继续跟踪
void CCPoolManager::addObject(CCObject* pObject)
{
    getCurReleasePool()-&gt;addObject(pObject);
}

// 添加到自动释放池的实际操作
void CCAutoreleasePool::addObject(CCObject* pObject)
{
    // 内部是由一个 CCArray 维护自动释放对象，并且此操作 会使引用 + 1
    m_pManagedObjectArray-&gt;addObject(pObject);

    // 由于初始化 引用为 1，上面又有操作，所以引用至少为 2 （可能还被其它所引用）
    CCAssert(pObject-&gt;m_uReference &gt; 1, "reference count should be greater than 1");
    ++(pObject-&gt;m_uAutoReleaseCount);
    // 变相的将自身引用转化为释放池引用，所以减 1
    pObject-&gt;release(); // no ref count, in this case autorelease pool added.
}
</code></pre>

<p>```</p>

<p>上面便是通过 <code>create()</code> 方法创建对象的过程。文中说到，一个合适的时机，解除自身引用（也就是释放池引用），那这又是在何时进行的呢？程序的运行有一个主循环，控制着每一帧的操作，在每一帧画面画完之时会自动调用 <code>CCPoolManager::sharedPoolManager()-&gt;pop();</code> 方法 ( 具体可参见文章<a href="http://blog.leafsoar.com/archives/2013/05-05.html">Cocos2d-x 程序是如何开始运行与结束的</a> ，这里我们只要知道每一帧结束都会调用 pop() 方法)，来自动清理 <strong>创建时期</strong> 的引用。现在我们就来看看 <code>pop()</code> 的方法实现：</p>

<p>``` c++</p>

<pre><code>void CCPoolManager::pop()
{
    if (! m_pCurReleasePool)
    {
        return;
    }

    // 当前释放池个数，pop 使用栈结构
     int nCount = m_pReleasePoolStack-&gt;count();
    // 释放池当中存放的都是 创建时期 对象，此时解除释放池引用
    m_pCurReleasePool-&gt;clear();

    // 当前释放池，出栈，在这里可以看到判断 nCount 是否大于 1，文后将会对此做具体说明
      if(nCount &gt; 1)
      {
        m_pReleasePoolStack-&gt;removeObjectAtIndex(nCount-1);

//         if(nCount &gt; 1)
//         {
//             m_pCurReleasePool = m_pReleasePoolStack-&gt;objectAtIndex(nCount - 2);
//             return;
//         }
        m_pCurReleasePool = (CCAutoreleasePool*)m_pReleasePoolStack-&gt;objectAtIndex(nCount - 2);
    }

    /*m_pCurReleasePool = NULL;*/
}

// 释放池引用清理工作
void CCAutoreleasePool::clear()
{
    // 如果释放池存在 创建时期 的对象
    if(m_pManagedObjectArray-&gt;count() &gt; 0)
    {
        //CCAutoreleasePool* pReleasePool;
#ifdef _DEBUG
        int nIndex = m_pManagedObjectArray-&gt;count() - 1;
#endif

        CCObject* pObj = NULL;
        CCARRAY_FOREACH_REVERSE(m_pManagedObjectArray, pObj)
        {
            if(!pObj)
                break;

            --(pObj-&gt;m_uAutoReleaseCount);
            //(*it)-&gt;release();
            //delete (*it);
#ifdef _DEBUG
            nIndex--;
#endif
        }
        // 移除释放池对创建时期对象的引用，从而使对象交由使用者全权管理
        m_pManagedObjectArray-&gt;removeAllObjects();
    }
}
</code></pre>

<p>```</p>

<p><strong>到这里，自动释放池的作用也就完成了！</strong> 可以说创建的对象在一帧 (<strong>但有特殊情况，下一段说明</strong>) 之后就完全脱离了 <strong>自动释放池的控制</strong>，自动释放池，对对象的管理也就在 <strong>创建时期起着作用</strong>！之后便交由使用者管理，释放。</p>

<hr />

<h2>对"释放池"的管理说明</h2>

<p>我们知道了释放池管理着 <strong>创建时期</strong> 的对象，那么对于释放池本身是如何管理的？我们知道对于释放池，只需要有一个就已经能够满足我们的需求了，而在 cocos2d-x 的设计中，使用了集合管理 <strong>一堆</strong> 释放池。而在实际，它们又发挥了多大的用处？</p>

<p>``` c++</p>

<pre><code>// 释放池管理接口
class CC_DLL CCPoolManager
{
    // 释放池对象集合
    CCArray*    m_pReleasePoolStack;
    // 当前操作释放池
    CCAutoreleasePool*                    m_pCurReleasePool;

    // 获取当前释放池
    CCAutoreleasePool* getCurReleasePool();
public:
    CCPoolManager();
    ~CCPoolManager();
    void finalize();
    void push();
    void pop();

    void removeObject(CCObject* pObject);
    // 添加一个 创建时期 对象
    void addObject(CCObject* pObject);

    static CCPoolManager* sharedPoolManager();
    static void purgePoolManager();

    friend class CCAutoreleasePool;
};

// 我们从 addObject 开始看起，由上文可以 addObject 是由 CCObject 的 autorelease 自动调用的
void CCPoolManager::addObject(CCObject* pObject)
{
    getCurReleasePool()-&gt;addObject(pObject);
}

CCAutoreleasePool* CCPoolManager::getCurReleasePool()
{
    // 如果当前释放池为空
    if(!m_pCurReleasePool)
    {
        // 添加一个
        push();
    }

    CCAssert(m_pCurReleasePool, "current auto release pool should not be null");

    return m_pCurReleasePool;
}

void CCPoolManager::push()
{
    CCAutoreleasePool* pPool = new CCAutoreleasePool();       //ref = 1
    m_pCurReleasePool = pPool;
    // 像集合添加一个新的释放池
    m_pReleasePoolStack-&gt;addObject(pPool);                   //ref = 2

    pPool-&gt;release();                                       //ref = 1
}
</code></pre>

<p>```</p>

<p>从 addObject 开始分析，我们知道在 addObject 之前，会首先判断是否有当前的释放池，如果没有则创建，如果有，则直接使用，可想而知，在任何使用，任何情况，通过 addObject 只需要创建一个释放池便已经足够使用了。事实上也是如此。再来看 pop 方法。</p>

<p>``` c++</p>

<pre><code>void CCPoolManager::pop()
{
    if (! m_pCurReleasePool)
    {
        return;
    }

     int nCount = m_pReleasePoolStack-&gt;count();
    // 清楚对 创建对象 的引用
    m_pCurReleasePool-&gt;clear();

    // 如果大于 1，这也保证着，在任何时候，总有一个释放池是可以使用的
      if(nCount &gt; 1)
      {
          // 移除当前的释放池
        m_pReleasePoolStack-&gt;removeObjectAtIndex(nCount-1);

//         if(nCount &gt; 1)
//         {
//             m_pCurReleasePool = m_pReleasePoolStack-&gt;objectAtIndex(nCount - 2);
//             return;
//         }
        // 将当前释放池设定为前一个释放池，也就是 “出栈”的操作
        m_pCurReleasePool = (CCAutoreleasePool*)m_pReleasePoolStack-&gt;objectAtIndex(nCount - 2);
    }

    /*m_pCurReleasePool = NULL;*/
}
</code></pre>

<p>```</p>

<p><strong>看到这里</strong> 我就不解了！什么情况下才能用到多个释放池？按照设计的逻辑根本用不到。带着这个疑问，我在 <code>CCPoolManager::push()</code> 方法之内添加了一句话打印（修改源代码） <code>CCLog("这里要长长长的 **********");</code> ，然后重新编译源文件，运行程序，发现实际的使用中，push 只被调用了两次！我们知道，通过 addObject 可能会自动调用 <code>push()</code> 一次，但也仅有一次，所以一定是哪里手动调用了 <code>push()</code> 方法，才会出现这种情况，所以我继续翻看源代码，定位到了 <code>bool CCDirector::init(void)</code> 方法，在这里进行了游戏的全局初始化相关工作：</p>

<p>``` c++</p>

<pre><code>bool CCDirector::init(void)
{
    CCLOG("cocos2d: %s", cocos2dVersion());

    ...
    ...
    m_dOldAnimationInterval = m_dAnimationInterval = 1.0 / kDefaultFPS;    
    m_pobScenesStack = new CCArray();
    m_pobScenesStack-&gt;init();

    ...
    ...
    m_fContentScaleFactor = 1.0f;

    ...
    ...
    // touchDispatcher
    m_pTouchDispatcher = new CCTouchDispatcher();
    m_pTouchDispatcher-&gt;init();

    // KeypadDispatcher
    m_pKeypadDispatcher = new CCKeypadDispatcher();

    // Accelerometer
    m_pAccelerometer = new CCAccelerometer();


    // 这里手动调用了 push 方法，而在这之前的初始化过程中，间接的使用了 CCObject 的 autorelease，已经触发过一次 push 方法
    CCPoolManager::sharedPoolManager()-&gt;push();

    return true;
}
</code></pre>

<p>```</p>

<p><strong>所以我们便能够看到 push 方法被调用了两次</strong>，但其实如果我们把这里的手动调用放在方法的开始处，或者干脆就不使用 <code>CCPoolManager::sharedPoolManager()-&gt;push();</code> ，对程序也没任何影响，这样从头到尾，<strong>只创建了一个自动释放池，而这里多创建的一个并没有多大的用处。</strong> 或者用处不甚明显，因为多创建一个释放池是有其效果的，效果具体体现在哪里，那就是 <strong>可以使调用 push() 方法之前的对象，多存活一帧。</strong>，因为 pop 方法只对当前释放池做了 clear 释放。为了方便起见，我们使用 <a href="http://blog.leafsoar.com/archives/2013/05-22.html">Cocos2d-x 内存管理浅说</a> 里面的方法观察每一帧的情况，看下面测试代码：</p>

<p>``` c++</p>

<pre><code>// 关键代码如下
CCLog("update index: %d", updateCount);

// 在不同的帧做相关操作，以便观察
if (updateCount == 1) {
    // 创建一个自动管理对象
    layer = LSLayer::create();
    // 创建一个新的自动释放池
    CCPoolManager::sharedPoolManager()-&gt;push();
    // 再创建一个自动管理对象
    sprite = LSSprite::create();
} else if (updateCount == 2) {

} else if (updateCount == 3) {

}

CCLog("update index: %d end", updateCount);

/// 打印代码如下
cocos2d-x debug info [update index: 1]
// 第一帧创建了两个自动管理对象
cocos2d-x debug info [LSLayer().()]
cocos2d-x debug info [LSSprite().()]
cocos2d-x debug info [update index: 1 end]
// 第一个过度帧只释放了 sprite 对象
cocos2d-x debug info [LSSprite().~()]
cocos2d-x debug info [update index: 2]
cocos2d-x debug info [update index: 2 end]
// 第二个过度帧释放了 layer 对象
cocos2d-x debug info [LSLayer().~()]
cocos2d-x debug info [update index: 3]
cocos2d-x debug info [update index: 3 end]
</code></pre>

<p>```</p>

<p>可以对比 sprite 和 layer 对象，两个对象被放在了不同的自动释放池之中。这就是 手动调用 <code>push()</code> 方法所能达到的效果，至于怎么利用这个特性，<strong>帮助我们完成特殊的功能？我想还是不用了</strong>，这会增加我们程序设计的 <strong>复杂度</strong>，在我看来，甚至想把，cocos2d-x 2.0.4 中那唯一一次调用的 <code>push()</code> 给删了，以保持简单（程序的第一次初始化“可能”会用到这个特性，不过目测是没有多大关系的了 : P），在这里只系统通过这个例子理解 自动释放池是怎样被管理的即可！</p>

<p>从自动释放池管理 <strong>创建时期</strong> 对象，再到对释放池的管理，我们已经大概了解了一个对象的生命周期经历了哪些！ 下面简单说说 <strong>使用时期</strong> 的对象管理。</p>

<hr />

<h2>树形结构的链式反应</h2>

<p>文中我们知道了，自动释放池的存在意义，在于对象 <strong>创建时期</strong> 的处理，而仅仅理解了自动释放池，对于我们使用 cocos2d-x 不够，远远不够！自动释放池只是解决对象初始化的问题，仅此而已，而要在整个使用过程中，相对的自动化管理，那么必须理解两个概念，<strong>树形结构</strong> 和 <strong>链式反应</strong> （链式反应，不错的说法，就像原子弹爆炸一样，一传十，十传百 ：P）</p>

<p>我们当前运行这一个场景，场景初始化，添加了很多层，层里面有其它的层或者精灵，而这些都是 CCNode 节点，以场景为根，形成一个树形结构，场景初始化之后（一帧之后），这些节点将完全 <strong>依附</strong> (内部通过 retain) 在这个树形结构之上，全权交由树来管理，当我们 <strong>砍去一个树枝</strong>，或者将树 <strong>连根拔起</strong>，那么在它之上的“子节点”也会跟着去除(内部通过 release)，这便是链式反应。</p>

<p><a href="http://blog.leafsoar.com/archives/2013/05-29.html">Cocos2d-x 内存管理的一种实现</a>，此文这种实现的本质既是 <strong>强化</strong>这种 <strong>链式反应</strong>，也是解决内存可能出错的一个解决方案。如下（前文片段，具体详见前文）：</p>

<p>``` c++</p>

<pre><code>// 方式一：那么我们的使用过程
LUser* lu = LUser::create();
lu-&gt;m_sSprite = CCSprite::create("a.png");
// 如果这里不 retain  则以后就用不到了
lu-&gt;m_sSprite-&gt;retain();

// 方式二：使用方法
LUser* lu = LUser::create();
lu-&gt;m_sUserName = "一叶";
// 这里的 sprite 会随着 lu 的消亡而消亡，不用管释放问题了
lu-&gt;setSprite(CCSprite::create("a.png"));
</code></pre>

<p>```</p>

<p>我们看到方式二相比方式一的设计，它通过 setSprite 内部对 sprite 本身 retain，从而实现<strong>链式反应</strong>，而不是直接使用 <code>lu-&gt;m_sSprite-&gt;retain();</code>，这样的好处是，我只要想着释放 LUser，而不用考虑LUser 内部 sprite 的引用情况就行了。如此才能把 cocos2d-x 内存的自动管理特性完全发挥 ~</p>

<p>而要实现这样管理的一个明显特征就是，隐藏 <code>retain</code> 和 <code>release</code> 操作 ~</p>

<hr />

<h2>稍作总结</h2>

<p>关于 cocos2d-x 的内存管理从使用到原理，系列文章就到这里了！（三篇也算系列 = =!） 由表象到内部的思考探索过程，其实在 <strong>浅说</strong> 当中对 cocos2d-x 的使用，便已经能够知晓内部细节设计之一二，透过现象看本质！三篇文章包含了，使用浅说（简单的测试），一种防止内存泄漏的设计（加强链式反应），最后纵览 cocos2d-x 的内存管理框架，对 CCObject 的生命周期做了简单的说明，当然其中还是隐藏一些细节的，比如管理都是用 CCArray 来管理，但我们并没有对 CCArray 做介绍，它是如何添加元素，如何引用等。在任何时候我们只针对一个问题进行思考，那我们该把 CCArray 这样的辅助工具类放在何处，如果你了解当然最好，不过不了解，那便 <strong>存疑</strong> ，然后对相应的问题，分而治之 ~</p>

<p><strong>存疑</strong> 可以帮助一叶在某个时刻只针对某一个问题进行思考，从而使问题变的简单。对文中所涉及的到的两个类 <code>CCPoolManager</code> 和 <code>CCAutoreleasePool</code> 其中所有的方法并没有面面俱到，当然有了整体思路，去 <strong>填充那些</strong> 小疑问将会变得简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocos2d-x 内存管理的一种实现]]></title>
    <link href="http://blog.leafsoar.com/archives/2013/05-29.html"/>
    <updated>2013-05-29T10:10:00+08:00</updated>
    <id>http://blog.leafsoar.com/archives/2013/cocos2dx-property</id>
    <content type="html"><![CDATA[<p>使用 Cocos2d-x 编写游戏，常被人吐槽，吐槽什么，当然是内存管理，C++ 的使用本以不易，而在 Cocos2d-x 添加了半内存自动管理，在这么一种 <strong>复合机制</strong> 下，使得出现内存问题的概率直线飙升 ~</p>

<p>而关于这一点，可能在于并没有一个通用的合理的内存管理方式，能够更好的使用 Cocos2d-x ，或者说，缺少那么一种 <strong>规范</strong>，如果存在了这么一种 <strong>规范</strong>，而使得 Cocos2d-x 更为简单优雅，那势必是游戏的开发过程，更加从新所欲，把重点放在游戏本身的设计之上。</p>

<h2>Retain 与 Release 乃万恶之源</h2>

<p>稍微了解一点就能知道 Cocos2d-x 是基于引用计数来管理内存的，应用计数的加减就是 retain 和 release 方法的实现。在大多数情况下我们不用 <strong>显示</strong> 的去调用这两种方法，如在 <strong>CCNode</strong> 的 <strong>addChild</strong> 和 <strong>removeChild</strong> 方法，<strong>CCArray</strong> 的 <strong>addObject</strong> 和 <strong>removeObject</strong> 等这样成双成对的方法，对于这些的使用很简单，一叶上篇文章 <strong><a href="http://blog.leafsoar.com/archives/2013/05-22.html">Cocos2d-x 内存管理浅说</a></strong> 从概念上简单的分析了内部对象的生命周期特点，在此 <strong>浅说</strong> 之中，我刻意的绕过了它的底层实现，并没有深究其原理，对引用计数等概念也只是几句话一带而过，重点放在使用者该关心什么，该注意什么。因为我觉得 <strong>引用计数是个坑，一个很大的坑 ~</strong></p>

<!-- more -->


<p>当我们想要长期 <strong>持有</strong> 某个对象的时候，我们会用到 retain 和 release 方法，而这种情况我们会经常遇到，如那些 <strong>非CCNode</strong> 类型，比如一个运行场景里面有一个 <strong>CCString</strong> （以CCString 为例，显然此刻你更愿意用 std::string）保存的场景名称，以便我们随时使用，那我们一个简单的做法就是在场景初始化的时候创建 CCString 对象，赋值，然后 retain，在场景结束或者析构函数中 release，这很简单，一个 retain 对应一个 release 就没有问题了，如果问题稍微变的复杂，在程序的运行中，我们可能会改变这个属性值，创建一个新的 CCString 去替换它，那在执行这些操作的时候我们需要很多判断，是否已经有值，首先要解除之前的引用，在重新引用新的对象~~<strong>诸如此类</strong>，如果中间不需要此对象，中间直接释放，那么我们会 <strong>非常华丽的看到在程序代码之中到处穿插着 retain 和 release 操作</strong>。而这些 retain 和 release 虽然成对出现，但不一定在同一个方法，<strong>这就演变成了，所在的不同方法也要成对的调用。</strong></p>

<p><strong>你把青蛙放到冷水里，再慢慢地加热，青蛙感觉不到什么，直到最后被烫死。</strong> 使用 retain 和 release 就正如温水里的青蛙，刚开始到也没觉得什么，引用计数概念多好。而到后来，发现越来越难以控制，为时以晚矣～</p>

<p>“如果说C语言给了你足够的绳子吊死自己，那么C++给的绳子除了够你上吊之外，还够绑上你所有的邻居，并提供一艘帆船所需的绳索。”（摘自 <strong>UNIX痛恨者手册</strong>） 而此时 ~~~</p>

<h2>建立规范 完全消灭 retain 和 release</h2>

<p>既然说 retain 和 release 乃万恶之源，那么我们只要 <strong>从源头上，解决这个问题</strong>，如此一切将会变的非常简单，我们将建立一种类似 addChild 这样的 <strong>内部处理</strong> 机制，不用显示的调用 retain 和 release ，从而杜绝了 retain “漫天飞”的可能。而要实现这样的机制，只需简单的设计即可 ~代码实现如下<a href="https://github.com/leafsoar/ls-cocos2d-x/blob/master/Learn/Classes/Property/Property.h">源码示例</a>：</p>

<p>``` c++</p>

<pre><code>// 为了方便起见，自定义宏，并且为 varName 的实现加上了 __ls_ 的前缀，前缀可以修改，可以很长很长很长
// 加 __ls_ 前缀是为了，在使用的过程只通过 set 和 get 属性包装器调用，而不要直接使用此属性
#define LS_PRE(p) __ls_##p
//#define LS_PRE(p) __retain_##p            // 其它前缀都行，目的是为了不让在直接使用此类型对象

//  此处定义以弃用
//  #define LS_PROPERTY_RETAIN(varType, varName, funName)\
//  private: varType LS_PRE(varName);\
//  public: void set##funName(varType value){\
//      CC_SAFE_RELEASE_NULL(LS_PRE(varName));\
//      LS_PRE(varName) = value;\
//      CC_SAFE_RETAIN(LS_PRE(varName));\
//  }; \
//  public: varType get##funName(){return LS_PRE(varName);};

// 经朋友提醒，发现 cocos2d-x 已经实现了相应功能的宏，并且更好用，那这里的二次包装就算是仅仅加个前缀吧 ！！！
#define LS_PROPERTY_RETAIN(varType, varName, funName)\
    CC_SYNTHESIZE_RETAIN(varType, LS_PRE(varName), funName);

// 初始化和释放包装宏，主要为了封装前缀，始定义统一
#define LS_P_INIT(p) LS_PRE(p)(0)
#define LS_P_RELEASE(p) CC_SAFE_RELEASE_NULL(LS_PRE(p))

/**
 * 自定义类型数据：用户信息
 */
class LUser: public cocos2d::CCObject{
public:
    CREATE_FUNC(LUser);
    virtual bool init(){
        return true;
    };
    LUser(){
        CCLog("LUser()");
    };
    ~LUser(){
        CCLog("LUser().~():%s", m_sUserName.c_str());
    };

    std::string m_sUserName;        // 用户名
    std::string m_sPassword;        // 用户密码
};

class PropertyTest: public CCLayer{
public:
    CREATE_FUNC(PropertyTest);

    virtual bool init(){
        CCLog("PropertyTest().init()");
        LUser* lu = LUser::create();
        lu-&gt;m_sUserName = "leafsoar";
        lu-&gt;m_sPassword = "123456";
        setLUser(lu);

        // 为了方便在不同帧测试，启用定时器
        this-&gt;scheduleUpdate();

        return true;
    };

    virtual void update(float fDelta){
            // 为了方便观察，不让 update 内部无止境的打印下去
            if (updateCount &lt; 5){
                updateCount ++;
                CCLog("update index: %d", updateCount);
                // 在不同的帧做相关操作，以便观察
                if (updateCount == 1){
                    // 这里使用 getLUser 获取数据，而非 [__ls_]m_pLUser，所以我设置了前缀
                    if (getLUser())
                        CCLog("log lu: %s", getLUser()-&gt;m_sUserName.c_str());

                } else if (updateCount == 2){
                    // 重新赋值
                    LUser* lu = LUser::create();
                    lu-&gt;m_sUserName = "一叶";
                    setLUser(lu);
                } else if (updateCount == 3){
                    if (getLUser())
                        CCLog("log lu: %s", getLUser()-&gt;m_sUserName.c_str());
                } else if (updateCount == 4){
                    // 这里调用 seLUser(0),直接取消引用持有对象，如果不调用也没有关系
                    // 因为在当前类析构的时候会自动检测释放
                    setLUser(0);
                }
                CCLog("update index: %d end", updateCount);
            }
        };

    // 构造函数，初始化 LS_PROPERTY_RETAIN 属性为空
    PropertyTest():
        LS_P_INIT(m_pLUser),
        updateCount(0)
    {
    };

    // 析构函数释放
    ~PropertyTest(){
        LS_P_RELEASE(m_pLUser);
    };

    // 使用 LS_PROPERTY_RETAIN 宏定义的属性，必须在构造和析构函数中初始化和释放
    // 初始化为 0 或者 NULL，是为了在进行赋值操作前判断是否以有引用
    // 析构函数释放是为了解除对持有对象的引用，如果有的话
    LS_PROPERTY_RETAIN(LUser*, m_pLUser, LUser);

private:
    int updateCount;
};

/// 程序执行打印如下
cocos2d-x debug info [PropertyTest().init()]
// init 方法创建对象并通过 setLUser 持有对象
cocos2d-x debug info [LUser()]
cocos2d-x debug info [update index: 1]
// 第一帧顺利访问 持有对象
cocos2d-x debug info [log lu: leafsoar]
cocos2d-x debug info [update index: 1 end]
cocos2d-x debug info [update index: 2]
// 第二帧创建新的 用户信息
cocos2d-x debug info [LUser()]
// 通过 setLUser 改变用户信息，这会使得之前设置的用户信息“自动”释放
cocos2d-x debug info [LUser().~():leafsoar]
cocos2d-x debug info [update index: 2 end]
cocos2d-x debug info [update index: 3]
// 跨帧继续访问新值
cocos2d-x debug info [log lu: 一叶]
cocos2d-x debug info [update index: 3 end]
cocos2d-x debug info [update index: 4]
// 调用了 setLUser(0) 说明已经解除了之前持有对象的引用，如果有的话
cocos2d-x debug info [LUser().~():一叶]
cocos2d-x debug info [update index: 4 end]
cocos2d-x debug info [update index: 5]
cocos2d-x debug info [update index: 5 end]
</code></pre>

<p>```</p>

<p>通过上面的例子，可以看到将 <strong>持有对象</strong> 的操作变的非常简单，<strong>只通过</strong> set 和 get 属性包装器存取数据，而并没有 <strong>显示</strong> 的调用 retain 和 release 方法来操作，最大程度的自动化管理引用计数问题，一切皆在掌控之中。从此，世界清净了 ~ <strong>你不用再为何时 retain 何处 release 而烦恼。</strong></p>

<p>而要做到如上的使用方法，在定义之初需规范化设计，大致如下：</p>

<ul>
<li>通过 <strong>LS_PROPERTY_RETAIN</strong> 宏创建 <strong>可持有对象属性</strong>，并自动创建 set 和 get 属性包装器。宏的设计并非毫无来由，我们知道 cocos2d-x 内部定义了很多以 <strong>CC_</strong> 为前缀的宏，方便使用，比如 <strong>CC_PROPERTY[xxx]</strong> 此类。set 方法会自动的根据需要处理 retain 和 release。</li>
<li>宿主类的构造函数必须初始化对象为 NULL 或者 0，这是 C++ 的特性使然。LS_P_INIT，简化了操作。</li>
<li>宿主类的析构函数必须释放对象[如果有]，这样我们就不用 <strong>显示</strong> 的调用释放了。可以通过 LS_P_RELEASE 调用。</li>
</ul>


<h3>LS_PROPERTY_RETAIN 宏的实现</h3>

<p>在上面的例程中，我们使用了 <strong>LS_PROPERTY_RETAIN(LUser*, m_pLUser, LUser);</strong> 定义一个属性，那么我们看这个宏做了哪些事情，我们展开这个宏看看：</p>

<p>``` c++</p>

<pre><code>LS_PROPERTY_RETAIN(LUser*, m_pLUser, LUser);
// 展开如下
private:
    // 定义私有属性
    LUser* __ls_m_pLUser;
public:
    // 实现 set 方法
    void setLUser(LUser* var){
        // 首先释放当前的持有对象，没有则罢，如果有，那么就 release，因为如果有值，毕定是通过此方法设置并 retain 的
        if (__ls_m_pLUser != var){
            // 持有新的对象，这些都是 SAFE  安全操作的
            CC_SAFE_RETAIN(var);
            // 这里是 cocos2d-x 提供的宏，就不展开了               
            CC_SAFE_RELEASE(__ls_m_pLUser);
            // 设置新的属性
            __ls_m_pLUser = var;
        }
    }; 
public:
    LUser*  getLUser(){
        // 直接返回持有对象
        return __ls_m_pLUser;
    };
</code></pre>

<p>```</p>

<p>基本在设计之时，满足以上规范，就能想这里一样，通过 set 和 get 简单的对可持有对象进行任意的操作了。</p>

<h2>应用</h2>

<p>这样的设计使得 <strong>所有基于</strong> CCObject 的类型都能够方便的使用。那我们就能够很容易的持有 CCNode，层，精灵，CCArray，等数据了。而且不会看到漫天飞舞的 retain 和 release ~</p>

<p>当然作用还不止如此，我们可能创建自己的类型继承 CCObject 以方便统一管理，在配合 CCArray ，使自定义的数据和 cocos2d-x <strong>无缝的集成</strong>。有些游戏需要处理很多数据，如网络传输接受的数据，自定义常用数据等 ~</p>

<p>文中我们自定义了 LUser 是继承于 CCObject  的，这只是简单数据类型，复杂点的，LUser 中包含了其它 CCObject 的数据，如果按照以前的写法，设置之后就 retain ，那很难判断在哪里 release。如下：</p>

<p>``` c++</p>

<pre><code>class LUser: public cocos2d::CCObject{
public:
    CREATE_FUNC(LUser);
    virtual bool init(){
        return true;
    };
    LUser(){
        CCLog("LUser()");
    };
    ~LUser(){
        CCLog("LUser().~():%s", m_sUserName.c_str());
    };

    std::string m_sUserName;        // 用户名
    std::string m_sPassword;        // 用户密码

    // 其它数据
    CCSprite* m_pSprite;
};

// 那么我们的使用过程
LUser* lu = LUser::create();
lu-&gt;m_sSprite = CCSprite::create("a.png");
// 如果这里不 retain  则以后就用不到了
lu-&gt;m_sSprite-&gt;retain();
</code></pre>

<p>```</p>

<p>LUser 持有 m_sSprite 正如 文中 PropertyTest 持有 m_pLUser 一样，我们重新设计：</p>

<p>``` c++</p>

<pre><code>class LUser: public cocos2d::CCObject{
public:
    CREATE_FUNC(LUser);
    virtual bool init(){
        return true;
    };
    LUser():
        LS_P_INIT(m_pSprite)
    {
        CCLog("LUser()");
    };
    ~LUser(){
        CCLog("LUser().~():%s", m_sUserName.c_str());
        LS_P_RELEASE(m_pSprite);
    };

    std::string m_sUserName;        // 用户名
    std::string m_sPassword;        // 用户密码

    // 其它数据
    LS_PROPERTY_RETAIN(CCSprite*, m_pSprite, Sprite);

};

// 使用方法
LUser* lu = LUser::create();
lu-&gt;m_sUserName = "一叶";
// 这里的 sprite 会随着 lu 的消亡而消亡，不用管释放问题了
lu-&gt;setSprite(CCSprite::create("a.png"));
</code></pre>

<p>```</p>

<p>这样便将 m_pSprite 控制权，完全交给了 LUser 来处理了。基于这样的考虑，我们完全可以使用复杂的自定义类型，包含很多 CCObject 属性，而属性之中可能又包含其它 CCObject 的类型，而并不用担心释放问题，<strong>谁持有，谁管理，谁释放</strong>(而不会出现 lu->m_sSprite->retain(); 这样的情况)。这些数据可以在游戏中任意的传递，并且都是CCObject 类型的，并很好的结合 CCArray 管理。让自定义类型与 cocos2d-x 两者天衣无缝，配合无间 ~</p>

<p>这里自定义的宏，加了个复杂的前缀，仅仅想提醒大家，只通过 set 和 get 来进行存取的操作，从而避免使用 retain 和 release 来管理，更简单的写法，使用 cocos2d-x 自带的宏即可：</p>

<p>``` c++</p>

<pre><code>//  定义可以加 "__" 双下划，以告诉自己这是可持有属性
CC_SYNTHESIZE_RETAIN(LUser*, __m_pLUser, LUser);

// 构造函数直接使用 __m_pLUser(0)

// 析构函数调用如下
CC_SAFE_RELEASE_NULL(__m_pLUser);

// 如此倒也省事，事省 : P
</code></pre>

<p>```</p>

<h3>为什么 LUser 继承自 CCObject</h3>

<p>如果不集成自 CCObject 而使用原来的 C++ 方式也并无不可，但 CCObject 的优势是很明显的，如果能够善于使用。如果你想在 cocos2d-x 一个CCNode绑定数据有 setUserObject() 方法，如果多个 LUser 那么可以用 CCArray 进行管理，如果你想使用通知功能 CCNotificationCenter，而此  LUser 是可被传递的，我们设置了 LUser 然后靠诉别人我更新了，发送一条通知，谁对这个通知感兴趣，那谁就自己处理去吧 ~ 如果 ~ 如果你对此文感兴趣，不妨一试 ~</p>
]]></content>
  </entry>
  
</feed>
